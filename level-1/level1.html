<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>A Simple Journey — Level 1</title>
    <style>
  @font-face {
    font-family: 'PixelFont';
    src: url('./pixel-font.ttf') format('truetype');
    font-weight: normal;
    font-style: normal;
  }
  html,body{height:100%;margin:0;background:#111;color:#fff;overflow:hidden;font-family:'PixelFont', 'Courier New', monospace}
  /* center the canvas and constrain its displayed size so it never overflows */
  canvas{image-rendering:pixelated;display:block;background:#e9e9e9;position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);max-width:100%;max-height:100%;box-shadow:0 0 0 1px rgba(0,0,0,0.1)}
      .overlay{position:fixed;left:0;top:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.85)}
      .msg{
        background:#2a2a2a;
        padding:40px 50px;
        border:4px solid #ffffff;
        color:#f0f0f0;
        border-radius:0;
        font-family:'PixelFont', 'Courier New', monospace;
        box-shadow:0 8px 0 #000, 8px 0 0 #000, -8px 0 0 #000, 0 -8px 0 #000;
        image-rendering:pixelated;
      }
      .msg h2{
        font-size:36px;
        font-weight:700;
        letter-spacing:4px;
        margin:0 0 20px 0;
        text-shadow:3px 3px 0 #000;
      }
      .msg p{
        font-size:16px;
        letter-spacing:1px;
        margin:10px 0;
      }
      .msg button{
        background:#ffffff;
        color:#000000;
        border:3px solid #000000;
        padding:10px 28px;
        font-size:16px;
        font-family:'PixelFont', 'Courier New', monospace;
        letter-spacing:3px;
        cursor:pointer;
        border-radius:0;
        font-weight:700;
        box-shadow:4px 4px 0 #000;
        transition:all 100ms ease;
      }
      .msg button:hover{
        background:#e0e0e0;
        box-shadow:2px 2px 0 #000;
        transform:translate(2px, 2px);
      }
      .msg button:active{
        background:#d0d0d0;
        box-shadow:0 0 0 #000;
        transform:translate(4px, 4px);
      }
      .hint{
        display:none; /* Hide HTML hint, will draw on canvas instead */
      }
      .mute{
        display:none; /* Hide HTML mute, will draw restart button on canvas instead */
      }
      /* mobile controls */
      .controls{position:fixed;left:12px;bottom:12px;display:flex;gap:8px}
      .btn{width:64px;height:64px;border-radius:8px;background:rgba(0,0,0,0.35);display:flex;align-items:center;justify-content:center;color:#fff;font-weight:700;font-family:'PixelFont', 'Courier New', monospace;user-select:none}
      .startOverlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.85);z-index:20}
      .startBox{
        background:#2a2a2a;
        color:#f0f0f0;
        padding:40px 60px;
        border-radius:0;
        border:4px solid #ffffff;
        text-align:center;
        font-family:'PixelFont', 'Courier New', monospace;
        box-shadow:0 8px 0 #000, 8px 0 0 #000, -8px 0 0 #000, 0 -8px 0 #000;
        image-rendering:pixelated;
      }
      .startBox h2{
        font-size:48px;
        font-weight:700;
        letter-spacing:8px;
        margin:0 0 30px 0;
        text-shadow:4px 4px 0 #000;
        filter:none;
      }
      .startBox button{
        background:#ffffff;
        color:#000000;
        border:3px solid #000000;
        padding:12px 32px;
        font-size:18px;
        font-family:'PixelFont', 'Courier New', monospace;
        letter-spacing:4px;
        cursor:pointer;
        border-radius:0;
        transition:all 100ms ease;
        text-shadow:none;
        font-weight:700;
        box-shadow:4px 4px 0 #000;
      }
      .startBox button:hover{
        background:#e0e0e0;
        box-shadow:2px 2px 0 #000;
        transform:translate(2px, 2px);
      }
      .startBox button:active{
        background:#d0d0d0;
        box-shadow:0 0 0 #000;
        transform:translate(4px, 4px);
      }
      /* narrative card - mysterious floating text */
  .narrative{position:fixed;left:50%;top:8%;transform:translateX(-50%);z-index:25;pointer-events:none;opacity:0;transition:opacity 800ms ease;max-width:90vw}
  .narrative.show{opacity:1}
  /* floating translucent text - smaller, blurred, mysterious */
  .narrative .card{
    background:rgba(0,0,0,0.5);
    color:rgba(240,240,240,0.9);
    padding:12px 20px;
    border-radius:8px;
    border:2px solid rgba(255,255,255,0.6);
    display:block;
    font-family:'PixelFont', 'Courier New', monospace;
    font-size:22px;
    font-weight:300;
    letter-spacing:2px;
    text-shadow:0 0 15px rgba(0,0,0,0.4), 0 0 30px rgba(0,0,0,0.2);
    filter:blur(0.8px);
    white-space:nowrap;
    text-align:center;
  }
      .fadeScreen{position:fixed;inset:0;background:#000;opacity:0;pointer-events:none;transition:opacity 600ms ease;z-index:30}
    </style>
  </head>
  <body>
    <canvas id="game"></canvas>
    <div class="hint">
      <div style="font-weight:700;margin-bottom:8px;font-size:16px;">CONTROLS</div>
      <div>← → / A D : Move</div>
      <div>↑ / W / Space : Jump</div>
      <div>Shift : Run</div>
      <div style="margin-top:8px;font-size:12px;opacity:0.8;">Collect all coins</div>
    </div>
    <div id="muteBtn" class="mute">Mute</div>
    <div class="controls" id="touchControls" style="display:none">
      <div id="leftBtn" class="btn">◀</div>
      <div id="rightBtn" class="btn">▶</div>
      <div id="jumpBtn" class="btn">▲</div>
    </div>

    <div id="startOverlay" class="startOverlay">
      <div class="startBox">
        <h2>A  S I M P L E  J O U R N E Y</h2>
        <p style="font-size:18px;letter-spacing:2px;margin:20px 0;font-weight:700">Level 1</p>
        <p style="font-size:14px;letter-spacing:2px;margin:10px 0">← → or A D to move</p>
        <p style="font-size:14px;letter-spacing:2px;margin:10px 0">↑ W Space to jump</p>
        <p style="font-size:14px;letter-spacing:2px;margin:10px 0">Hold Shift to run</p>
        <button id="startBtn">B E G I N</button>
      </div>
    </div>

  <div id="narrative" class="narrative" aria-hidden="true"><div class="card" id="narrativeText"></div></div>
  <div id="fadeScreen" class="fadeScreen"></div>

    <div id="completeOverlay" class="overlay" style="display:none">
      <div class="msg">
        <h2>LEVEL 1 COMPLETE</h2>
        <p style="font-size:18px;margin:15px 0">Key: <strong style="font-size:24px">1030</strong></p>
        <p style="font-size:14px;margin:15px 0">Return to main menu and enter this key</p>
        <p style="font-size:14px;margin:15px 0">to unlock the next level</p>
        <div style="text-align:center;margin-top:25px"><button id="overlayClose">CONTINUE</button></div>
      </div>
    </div>

    <script>
      // Side-scrolling monochrome prototype inspired by calm walking games.
      (function(){
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');

        // virtual resolution (keeps 16px blocks alignment)
        const VW = 1920;
        const VH = 1088; // keep 16px grid -> 68 rows

        canvas.width = VW;
        canvas.height = VH;

        // scale canvas to fit window while preserving aspect
        function fit(){
          const scale = Math.min(window.innerWidth / VW, window.innerHeight / VH);
          canvas.style.width = Math.round(VW * scale) + 'px';
          canvas.style.height = Math.round(VH * scale) + 'px';
        }
        window.addEventListener('resize', fit);
        fit();

        // world
        const tile = 16; // 16px logical pixel
        let groundY = VH - 6 * tile; // ground baseline (will be updated when background loads)

        // visual / physics scale (increase to make everything larger on screen)
          const SPRITE_DRAW_SCALE = 4; // visual scale for sprite rendering (was 2)
          const PHYS_SCALE = SPRITE_DRAW_SCALE; // scale collision box to match visual size
          const VISUAL_SCALE = 4; // additional visual scale for non-physics elements (collectibles, decorations)
          // player (logical size defined here; y will be anchored to ground using scaled collision height)
          const player = { x: 120, y: 0, w:16, h:16, vx:0, onGround:true, dir:1, anim:0, vy:0 };
          // ensure player visually sits on the ground according to PHYS_SCALE (will update after bg loads)
          player.y = groundY - player.h * PHYS_SCALE;

        // camera
        let camX = 0;

  // controls
  const keys = {};
  window.addEventListener('keydown', e=>{ 
    keys[e.key] = true;
    
    // Word guessing input
    if (showingPrompt && activeWordIndex >= 0) {
      const key = e.key.toUpperCase();
      e.preventDefault(); // Prevent default keyboard behavior when typing
      
      if (key === 'ESCAPE') {
        // Exit input mode
        currentInput = '';
        showingPrompt = false;
        activeWordIndex = -1;
        Object.keys(keys).forEach(k => keys[k] = false);
        showNarrative('Search the world for clues...', 2000);
      } else if (key === 'BACKSPACE') {
        currentInput = currentInput.slice(0, -1);
      } else if (key === 'ENTER') {
        // Check if word is correct
        const puzzle = wordPuzzles[activeWordIndex];
        if (currentInput === puzzle.word) {
          // Correct! Start coin animation
          const coin = collectibles[activeWordIndex];
          const coinScreenX = coin.x - camX;
          const coinScreenY = coin.y;
          
          // Start animation
          coinAnimation = {
            startX: coinScreenX,
            startY: coinScreenY,
            startTime: performance.now(),
            coinIndex: activeWordIndex,
            targetCount: displayedCoinCount + 1
          };
          
          collectibles[activeWordIndex].unlocked = true;
          collectibles[activeWordIndex].collected = true;
          playPickup();
          
          currentInput = '';
          showingPrompt = false;
          activeWordIndex = -1;
          // Clear all movement keys to prevent stuck movement
          Object.keys(keys).forEach(k => keys[k] = false);
        } else {
          // Wrong answer
          showNarrative('Try again...', 1500);
          currentInput = '';
        }
      } else if (key.length === 1 && key.match(/[A-Z]/)) {
        // Add letter to input
        currentInput += key;
      }
    }
  });
  window.addEventListener('keyup', e=>{ 
    keys[e.key] = false;
  });
  
  // Clear all keys when window loses focus (prevents stuck keys)
  window.addEventListener('blur', ()=> {
    Object.keys(keys).forEach(k => keys[k] = false);
    lastJumpPressed = false;
  });
  
  // jump input should be edge-triggered; track key state for jump
  const jumpKeys = ['ArrowUp','w','W',' '];

  // world features: parallax layers and collectibles as items
        const layers = [
          {color:'#dcdcdc', speed:0.1, y:200, h:200},
          {color:'#bfbfbf', speed:0.3, y:360, h:180},
          {color:'#9f9f9f', speed:0.6, y:520, h:220}
        ];

        // platforms and collectibles
        const platforms = [
          {x:0, y:0, w:20000, h:6} // Will be repositioned when background loads; width matches long scene
        ];

        // Word guessing game - 3 words to unlock 3 coins
        const wordPuzzles = [
          { word: 'STONE', hint: 'A small ____ rests quietly', x: 2400 },
          { word: 'TREE', hint: '____ shadows drift past', x: 5600 },
          { word: 'TIME', hint: 'Walk slowly leave ____', x: 8800 }
        ];
        
        let currentInput = '';
        let activeWordIndex = -1; // Which word puzzle is active
        let showingPrompt = false;
        
        // Coin collection animation
        let coinAnimation = null; // { startX, startY, startTime, coinIndex, targetCount }
        const COIN_ANIM_DURATION = 1000; // 1 second animation
        let displayedCoinCount = 0; // For animated counter
        
        // Generate coin collectibles
        const collectibles = [];
        wordPuzzles.forEach((puzzle, idx) => {
          collectibles.push({
            x: puzzle.x,
            y: 0,
            w: 12,
            h: 12,
            wordIndex: idx,
            collected: false,
            unlocked: false, // Unlocked when word is guessed
            nearPlayer: false
          });
        });

        // Update platform and collectible Y positions when background loads
        function updateGroundPositions(){
          const visualGround = window.VISUAL_GROUND_Y || groundY;
          platforms.forEach(p => { p.y = visualGround; });
          collectibles.forEach(c => { 
            c.y = visualGround - 40; // place collectibles above ground
          });
          // Update player initial position
          player.y = visualGround - player.h * PHYS_SCALE;
        }

        const COLLECT_TARGET = 3; // Need to collect 3 coins to win

  // walking sprite (16x16) monochrome frames — 6 subtle frames for smoother movement
  const SPRITES = [
          [
            '0000000000000000','0000011111000000','0000111111100000','0001111111110000','0011111111111000','0011111111111000','0111111111111100','0111101110111100','0111101110111100','0111111111111100','0011110011111000','0011100001111000','0001100000110000','0000110001100000','0000011110000000','0000000000000000'
          ],
          [
            '0000000000000000','0000011111000000','0000111111100000','0001111111110000','0011111111111000','0011111111111000','0111111111111100','0111011110111100','0111101110111000','0111111111111000','0011110011111000','0011100001111000','0001100000110000','0000110001100000','0000011110000000','0000000000000000'
          ],
          [
            '0000000000000000','0000011111000000','0000111111100000','0001111111110000','0011111111111000','0011111111111000','0111111111111100','0111101110111100','0111110110111100','0111111111111100','0011110011111000','0011100001111000','0001100000110000','0000110001100000','0000011110000000','0000000000000000'
          ],
          [
            '0000000000000000','0000011111000000','0000111111100000','0001111111110000','0011111111111000','0011111111111000','0111111111111100','0111101110111100','0111101110111100','0111111111111100','0011110011111000','0011100001111000','0001100000110000','0000110001100000','0000011110000000','0000000000000000'
          ]
        ];

  let animTick = 0;
  // physics
  const GRAV = 1200; // px/s^2
  const JUMP_V = -520; // px/s
  
  // Track previous jump key state for edge detection
  let lastJumpPressed = false;
  
        // audio
        let audioCtx = null;
        let muted = false;
        function ensureAudio(){
          if(audioCtx) return;
          try{ audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }catch(e){ audioCtx = null; }
        }
        function playTone(freq, time=0.08, type='sine', gain=0.08){
          if(muted) return;
          ensureAudio(); if(!audioCtx) return;
          const o = audioCtx.createOscillator();
          const g = audioCtx.createGain();
          o.type = type; o.frequency.value = freq;
          g.gain.value = gain;
          o.connect(g); g.connect(audioCtx.destination);
          o.start();
          g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + time);
          o.stop(audioCtx.currentTime + time + 0.02);
        }
        function playStep(){ playTone(200, 0.06, 'triangle', 0.03); }
        function playPickup(){ playTone(880, 0.18, 'sine', 0.12); }

        function update(dt){
          if (!dt || dt <= 0) return; // Safety check
          
          // track previous grounded state for proper jump edge detection
          const wasOnGround = !!player.onGround;
          // reset grounded state; will be set during collision check
          player.onGround = false;
          
          // ===== MOVEMENT INPUT - Completely Rewritten =====
          // Don't move when typing in word puzzle
          if (showingPrompt && activeWordIndex >= 0) {
            player.vx = 0;
            player.anim = 0;
            player.running = false;
          } else {
            const left = keys['ArrowLeft'] || keys['a'] || keys['A'];
            const right = keys['ArrowRight'] || keys['d'] || keys['D'];
            const shift = keys['Shift'];
            
            // Reset movement state
            player.vx = 0;
            player.anim = 0;
            player.running = false;
            
            // Apply movement based on keys pressed
            if(left && !right) {
              // Moving left only
              player.dir = -1;
              player.anim = 1;
              if(shift) {
                // Running left
                player.vx = -240;
                player.running = true;
              } else {
                // Walking left
                player.vx = -140;
                player.running = false;
              }
            } 
            else if(right && !left) {
              // Moving right only
              player.dir = 1;
              player.anim = 1;
              if(shift) {
                // Running right
                player.vx = 240;
                player.running = true;
              } else {
                // Walking right
                player.vx = 140;
                player.running = false;
              }
            }
            else if(left && right) {
              // Both pressed - move right (right has priority)
              player.dir = 1;
              player.anim = 1;
              if(shift) {
                player.vx = 240;
                player.running = true;
              } else {
                player.vx = 140;
                player.running = false;
              }
            }
            // else: neither pressed - stays at 0 (idle)
          }

          // (jump will be applied after collision resolves to use correct grounded state)

          // apply velocity
          const oldX = player.x;
          // horizontal
          player.x += player.vx * (dt/1000);
          // vertical physics
          player.vy = player.vy || 0;
          player.vy += GRAV * (dt/1000);
          player.y += player.vy * (dt/1000);

          // footsteps sound when moving
          if(player.anim && Math.abs(player.x - oldX) > 12){ playStep(); }

          // clamp
          if(player.x < 40 * PHYS_SCALE) player.x = 40 * PHYS_SCALE;

          // camera follows player with easing, clamp min at 0 (center the camera on player's collision center)
          const collisionW = player.w * PHYS_SCALE;
          const collisionH = player.h * PHYS_SCALE;
          const playerCenterX = player.x + collisionW * 0.5;
          const targetCam = Math.max(0, playerCenterX - VW*0.35);
          camX += (targetCam - camX) * Math.min(1, dt/200);

          // platform collision (simple ground) — use scaled collision box
          platforms.forEach(p=>{
            if(player.x + collisionW > p.x && player.x < p.x + p.w){
              if(player.y + collisionH > p.y && player.y + collisionH < p.y + p.h + 64){
                // snap to platform (align visual bottom correctly by using collisionH)
                player.y = p.y - collisionH;
                player.vy = 0;
                player.onGround = true;
              }
            }
          });

          // handle jump edge (press while grounded) after collision resolves
          const jumpPressed = jumpKeys.some(k => keys[k]);
          // Edge-triggered jump: only jump on the rising edge (when key just pressed)
          const jumpJustPressed = jumpPressed && !lastJumpPressed;
          if(jumpJustPressed && wasOnGround){ 
            player.vy = JUMP_V; 
            player.onGround = false; 
            playStep(); 
          }
          lastJumpPressed = jumpPressed; // Store for next frame

          // collectibles - check if player is near and show word puzzle
          collectibles.forEach((c, idx)=>{
            if(!c.collected){
              const isNear = player.x + collisionW > c.x && player.x < c.x + c.w && 
                             player.y + collisionH > c.y && player.y < c.y + c.h;
              
              c.nearPlayer = isNear;
              
              if (isNear && !c.unlocked) {
                // Show word puzzle prompt
                if (!showingPrompt) {
                  showingPrompt = true;
                  activeWordIndex = idx;
                  currentInput = '';
                }
              }
            }
          });

          // scenery proximity triggers
          if(typeof scenery !== 'undefined'){
            scenery.forEach(s=>{
              if(!sceneryTriggered.has(s.x)){
                if(Math.abs(player.x - s.x) < 96){
                  sceneryTriggered.add(s.x);
                  showNarrative(s.text || '', 2600);
                }
              }
            });
          }

          // check win
          const collectedCount = collectibles.filter(c=>c.collected).length;
          if(collectedCount >= COLLECT_TARGET && !window.LEVEL1_DONE){ window.LEVEL1_DONE = true; onComplete(); }
        }

        function draw(){
          // clear
          ctx.fillStyle = '#f4f4f4'; ctx.fillRect(0,0,VW,VH);

          // Draw the composite background with parallax scrolling and looping
          if(compositeBackground){
            const bgW = compositeBackground.width;
            const bgH = compositeBackground.height;
            
            // Scale background to fill screen height perfectly
            const bgScale = VH / bgH; // Scale to exactly fit screen height
            const scaledW = Math.ceil(bgW * bgScale); // Use ceil to prevent gaps
            const scaledH = VH; // Fill screen height exactly
            
            // Calculate background position with camera (moves with player)
            const bgX = -camX; // Background moves with camera
            const bgY = 0; // Anchor to top of screen
            
            // Draw the background in a loop to cover the entire visible area
            // Calculate the starting position for seamless looping
            const offset = bgX % scaledW;
            const startX = Math.floor(offset);
            
            // Draw enough tiles to cover the screen (with extra overlap to prevent gaps)
            for(let x = startX - scaledW; x < VW + scaledW; x += scaledW){
              ctx.drawImage(compositeBackground, Math.floor(x), bgY, scaledW + 1, scaledH);
            }
            
            // Update the actual ground level based on where player should walk
            // The ground layer is at approximately 85% from the top of the background image
            const groundRatioFromTop = 0.85; // ground is 85% down from top of background
            const visualGroundY = bgY + (scaledH * groundRatioFromTop);
            window.VISUAL_GROUND_Y = visualGroundY;
          }else{
            // Fallback: draw old procedural layers if composite not ready
            layers.forEach(layer=>{
              const px = - (camX * layer.speed) % (VW + 200);
              ctx.fillStyle = layer.color;
              for(let x = px - 200; x < VW; x += 400){
                ctx.fillRect(x, layer.y, 360, layer.h);
              }
            });
            // ground fallback
            ctx.fillStyle = '#d0d0d0';
            ctx.fillRect(0, groundY, VW, VH-groundY);
          }

          // draw collectibles (coins with word puzzles)
          collectibles.forEach((c, idx)=>{
            if(!c.collected){
              const cx = Math.round(c.x - camX);
              const cy = Math.round(c.y);
              
              // Draw coin (gold if unlocked, gray if locked)
              const isUnlocked = c.unlocked;
              const glowColor = isUnlocked ? 'rgba(200, 200, 200, 0.8)' : 'rgba(100, 100, 100, 0.5)';
              
              // Glow effect
              if (isUnlocked || c.nearPlayer) {
                ctx.save();
                const pulse = Math.sin(Date.now() * 0.005) * 0.3 + 0.7;
                ctx.shadowBlur = 30 * pulse;
                ctx.shadowColor = glowColor;
                ctx.fillStyle = isUnlocked ? 'rgba(200, 200, 200, 0.2)' : 'rgba(100, 100, 100, 0.1)';
                ctx.beginPath();
                ctx.arc(cx, cy, 40, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
              }
              
              // Draw coin using image or fallback to circle
              ctx.save();
              if (coinImage) {
                // Use coin spritesheet - assume 8 frames spinning animation
                const frameCount = 8;
                const frameIndex = Math.floor((Date.now() * 0.008) % frameCount);
                const frameW = coinImage.width / frameCount;
                const frameH = coinImage.height;
                const coinSize = 48; // Display size
                
                // Apply grayscale filter if locked
                if (!isUnlocked) {
                  ctx.filter = 'grayscale(100%) brightness(0.6)';
                }
                
                ctx.shadowBlur = isUnlocked ? 15 : 5;
                ctx.shadowColor = glowColor;
                
                ctx.drawImage(
                  coinImage,
                  frameIndex * frameW, 0, frameW, frameH,
                  cx - coinSize/2, cy - coinSize/2, coinSize, coinSize
                );
              } else {
                // Fallback: draw circle
                const coinColor = isUnlocked ? '#cccccc' : '#888888';
                ctx.fillStyle = coinColor;
                ctx.shadowBlur = isUnlocked ? 15 : 5;
                ctx.shadowColor = glowColor;
                ctx.beginPath();
                ctx.arc(cx, cy, 24, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = isUnlocked ? '#dddddd' : '#666666';
                ctx.lineWidth = 3;
                ctx.stroke();
              }
              ctx.restore();
              
              // Show word puzzle when near
              if (c.nearPlayer && !isUnlocked && showingPrompt && activeWordIndex === idx) {
                const puzzle = wordPuzzles[idx];
                
                // Draw puzzle box
                ctx.save();
                const boxW = 600;
                const boxH = 180;
                const boxX = cx - boxW/2;
                const boxY = cy - 200;
                
                // Box background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
                ctx.fillRect(boxX, boxY, boxW, boxH);
                ctx.strokeStyle = '#cccccc';
                ctx.lineWidth = 4;
                ctx.strokeRect(boxX, boxY, boxW, boxH);
                
                // Hint text
                ctx.fillStyle = '#ffffff';
                ctx.font = '22px "PixelFont", monospace';
                ctx.textAlign = 'center';
                ctx.fillText(puzzle.hint, cx, boxY + 40);
                
                // Input field
                ctx.fillStyle = 'rgba(150, 150, 150, 0.3)';
                ctx.fillRect(boxX + 50, boxY + 70, boxW - 100, 60);
                ctx.strokeStyle = '#aaaaaa';
                ctx.lineWidth = 3;
                ctx.strokeRect(boxX + 50, boxY + 70, boxW - 100, 60);
                
                // Current input
                ctx.fillStyle = '#dddddd';
                ctx.font = 'bold 36px "PixelFont", monospace';
                ctx.fillText(currentInput + '_', cx, boxY + 112);
                
                // Instructions
                ctx.fillStyle = '#bbbbbb';
                ctx.font = '18px "PixelFont", monospace';
                ctx.fillText('Type the word, press ENTER', cx, boxY + 145);
                
                // ESC hint
                ctx.fillStyle = '#888888';
                ctx.font = '14px "PixelFont", monospace';
                ctx.fillText('Press ESC to explore and find clues', cx, boxY + 168);
                
                ctx.restore();
              }
            }
          });

          // draw scenery (use loaded assets from scenery folder, fallback to SVG sprites, then procedural)
          if(typeof scenery !== 'undefined'){
            scenery.forEach(s=>{
              const sx = Math.round(s.x - camX);
              
              // Draw indicator light circle if this scenery has narrative text
              if(s.text && s.text.trim().length > 0){
                const now = performance.now();
                const pulse = Math.sin(now * 0.003) * 0.3 + 0.7; // Pulsing effect 0.4-1.0
                
                // Position the light circle at ground level below the scenery
                const lightY = (window.VISUAL_GROUND_Y || groundY) + (s.yOffset || 0);
                
                ctx.save();
                ctx.globalAlpha = pulse * 0.6;
                
                // Outer glow
                ctx.fillStyle = 'rgba(255, 255, 200, 0.3)';
                ctx.beginPath();
                ctx.arc(sx, lightY, 32, 0, Math.PI * 2);
                ctx.fill();
                
                // Middle ring
                ctx.fillStyle = 'rgba(255, 255, 220, 0.5)';
                ctx.beginPath();
                ctx.arc(sx, lightY, 20, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner bright core
                ctx.fillStyle = 'rgba(255, 255, 240, 0.8)';
                ctx.beginPath();
                ctx.arc(sx, lightY, 10, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
              }
              
              // First priority: check for loaded scenery assets
              let assetImg = null;
              if(s.type === 'house' && sceneryAssets.house) assetImg = sceneryAssets.house;
              else if(s.type === 'cow_tree' && sceneryAssets.cow_tree) assetImg = sceneryAssets.cow_tree;
              else if(s.type === 'item6' && sceneryAssets.item6) assetImg = sceneryAssets.item6;
              else if(s.type === 'item7' && sceneryAssets.item7) assetImg = sceneryAssets.item7;
              
              if(assetImg){
                // Draw loaded scenery asset
                const scale = s.scale || 1.5; // Default scale for scenery items
                const drawW = assetImg.width * scale;
                const drawH = assetImg.height * scale;
                const drawX = sx - drawW/2;
                const baseY = (typeof s.y === 'number') ? s.y : (window.VISUAL_GROUND_Y || groundY) - drawH;
                const drawY = baseY + (s.yOffset || 0); // Apply vertical offset
                ctx.drawImage(assetImg, drawX, drawY, drawW, drawH);
                return;
              }
              
              // Second priority: SVG sprite images
              const img = SPRITE_IMAGES[s.type];
              if(img){
                const iw = img.width; const ih = img.height;
                // allow type-specific scale (buildings should be larger)
                const typeScale = (s.type === 'building') ? 1.2 : 0.9;
                const drawW = Math.round(iw * typeScale);
                const drawH = Math.round(ih * typeScale);
                // anchor using s.y if provided (top Y), otherwise bottom-align to ground
                const drawX = sx - Math.round(drawW/2);
                const drawY = (typeof s.y === 'number') ? Math.round(s.y) : Math.round(groundY - drawH);
                ctx.drawImage(img, drawX, drawY, drawW, drawH);
                return;
              }
              
              // Fallback: richer procedural drawing anchored to s.y if present
              if(s.type === 'tree'){
                const h = 48; const trunkH = 20; const foliageH = h - trunkH;
                const topY = (typeof s.y === 'number') ? s.y : (groundY - h);
                // trunk
                ctx.fillStyle = '#8b6b3a'; ctx.fillRect(sx+6, topY + foliageH, 6, trunkH);
                // foliage
                ctx.fillStyle = '#d9d9d9'; ctx.beginPath(); ctx.ellipse(sx+9, topY + foliageH/2, 30, foliageH/2, 0, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#cfcfcf'; ctx.beginPath(); ctx.ellipse(sx+9, topY + foliageH/2 - 8, 22, foliageH/2 - 6, 0, 0, Math.PI*2); ctx.fill();
              }else if(s.type === 'bench'){
                const w = 44; const h = 12; const topY = (typeof s.y === 'number') ? s.y : (groundY - h - 2);
                ctx.fillStyle = '#cfcfcf'; ctx.fillRect(sx - Math.round(w/2), topY, w, h);
                ctx.fillStyle = '#9f9f9f'; ctx.fillRect(sx - Math.round(w/2), topY + h, 6, 10); ctx.fillRect(sx + Math.round(w/2) - 6, topY + h, 6, 10);
              }else if(s.type === 'building'){
                const w = 240; const h = 128; const topY = (typeof s.y === 'number') ? s.y : (groundY - h);
                ctx.fillStyle = '#e6e6e6'; ctx.fillRect(sx - Math.round(w/2), topY, w, h);
                ctx.fillStyle = '#d0d0d0'; ctx.fillRect(sx - 60, topY + 18, 80, 60);
                ctx.fillStyle = '#c0c0c0'; for(let pl=0;pl<6;pl++) ctx.fillRect(sx - 80, topY + 48 + pl*8, w-40, 6);
              }else if(s.type === 'sign'){
                const h = 40; const topY = (typeof s.y === 'number') ? s.y : (groundY - h);
                ctx.fillStyle = '#bfbfbf'; ctx.fillRect(sx, topY + 6, 6, h - 6);
                ctx.fillStyle = '#ffffff'; ctx.fillRect(sx + 8, topY + 12, 44, 12);
                ctx.fillStyle = '#d0d0d0'; ctx.fillRect(sx + 12, topY + 14, 28, 6);
              }else if(s.type === 'lamp'){
                const h = 56; const topY = (typeof s.y === 'number') ? s.y : (groundY - h);
                ctx.fillStyle = '#8b8b8b'; ctx.fillRect(sx + 8, topY + 6, 6, h - 6);
                ctx.fillStyle = '#fff6d6'; ctx.fillRect(sx - 8, topY - 6, 24, 12);
              }
            });
          }

          // draw player at center-ish
          const px = Math.round(player.x - camX);
          const py = Math.round(player.y);
          
          // Draw collision box for debugging (small rectangle showing actual hitbox)
          // HIDDEN - Uncomment to debug collision
          /*
          ctx.save();
          ctx.globalAlpha = 0.3;
          ctx.fillStyle = '#ff0000';
          ctx.fillRect(px, py, player.w * PHYS_SCALE, player.h * PHYS_SCALE);
          ctx.restore();
          */
          
          // subtle soft shadow under player collision box
          // HIDDEN - Uncomment to show shadow
          /*
          ctx.save();
          ctx.globalAlpha = 0.12;
          ctx.fillStyle = '#000';
          const shW = 10 * SPRITE_DRAW_SCALE;
          const shH = 3 * SPRITE_DRAW_SCALE;
          ctx.beginPath();
          ctx.ellipse(px + (player.w*PHYS_SCALE)/2, py + player.h * PHYS_SCALE + 2, shW, shH, 0, 0, Math.PI*2);
          ctx.fill();
          ctx.restore();
          */

          // draw player sprite (use loaded spritesheet if available, else fallback to hardcoded)
          const offsetX = -50; // Move sprite left 50px (30 + 20)
          const offsetY = -280; // Move sprite up 280px from physics position (260 + 20)
          
          if(playerWalkSheet && playerIdleSheet){
            // Use loaded sprite sheets
            if(player.anim){
              // Choose between Run and Walk animation
              const useRun = player.running && playerRunSheet;
              const sheet = useRun ? playerRunSheet : playerWalkSheet;
              const totalFrames = 10; // Both Run and Walk have 10 frames
              const frameIndex = Math.floor(animTick) % totalFrames;
              const sw = sheet.width / totalFrames;
              const sh = sheet.height;
              const dw = sw * 3; // Keep player at 3x scale
              const dh = sh * 3;
              ctx.save();
              if(player.dir === -1){
                // Flip horizontally - translate to sprite center, flip, draw centered
                const spriteDrawX = px + offsetX + dw / 2;
                ctx.translate(spriteDrawX, py + offsetY + dh / 2);
                ctx.scale(-1, 1);
                ctx.drawImage(sheet, frameIndex * sw, 0, sw, sh, -dw / 2, -dh / 2, dw, dh);
              }else{
                ctx.drawImage(sheet, frameIndex * sw, 0, sw, sh, px + offsetX, py + offsetY, dw, dh);
              }
              ctx.restore();
            }else{
              // Idle animation - 6 frames
              const totalFrames = 6;
              const frameIndex = Math.floor(animTick / 2) % totalFrames;
              const sw = playerIdleSheet.width / totalFrames;
              const sh = playerIdleSheet.height;
              const dw = sw * 3; // Keep player at 3x scale
              const dh = sh * 3;
              ctx.save();
              if(player.dir === -1){
                ctx.translate(px + (player.w * PHYS_SCALE) / 2, 0);
                ctx.scale(-1, 1);
                ctx.drawImage(playerIdleSheet, frameIndex * sw, 0, sw, sh, -(player.w * PHYS_SCALE) / 2 + offsetX, py + offsetY, dw, dh);
              }else{
                ctx.drawImage(playerIdleSheet, frameIndex * sw, 0, sw, sh, px + offsetX, py + offsetY, dw, dh);
              }
              ctx.restore();
            }
          }else{
            // fallback: draw hardcoded sprite pixel-by-pixel (monochrome) with 4-frame animation, scaled up
            const frameIndex = Math.floor(animTick) % SPRITES.length;
            const spriteData = SPRITES[frameIndex];
            for(let y=0;y<16;y++){
              const row = spriteData[y];
              for(let x=0;x<16;x++){
                if(row[x] === '1'){
                  ctx.fillStyle = '#0a0a0a';
                  const drawX = (player.dir === 1) ? (px + offsetX + x*SPRITE_DRAW_SCALE) : (px + offsetX + (15-x)*SPRITE_DRAW_SCALE);
                  const drawY = py + offsetY + y*SPRITE_DRAW_SCALE; // Apply offsetY to fallback sprite too
                  ctx.fillRect(drawX, drawY, SPRITE_DRAW_SCALE, SPRITE_DRAW_SCALE);
                }
              }
            }
          }

          // Optional: draw a small foreground pass from the composite background bottom portion
          // Disabled for now to keep scene clean
          /*
          if(compositeBackground){
            ctx.save();
            ctx.globalAlpha = 0.2;
            const bgW = compositeBackground.width;
            const bgH = compositeBackground.height;
            const parallaxSpeed = 0.5;
            const offsetX = -(camX * parallaxSpeed);
            const bgY = VH - bgH - 50;
            
            // Draw only bottom 30% of composite as foreground overlay
            const clipH = Math.round(bgH * 0.3);
            const clipY = bgH - clipH;
            
            ctx.drawImage(compositeBackground, 0, clipY, bgW, clipH, offsetX, bgY + clipY, bgW, clipH);
            ctx.restore();
          }
          */

          // HUD: Draw controls hint box (left-bottom corner)
          ctx.save();
          const hintX = 12;
          const hintY = VH - 140;
          const hintW = 180;
          const hintH = 128;
          
          // Draw hint box background
          ctx.fillStyle = 'rgba(0,0,0,0.8)';
          ctx.fillRect(hintX, hintY, hintW, hintH);
          
          // Draw hint box border
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 2;
          ctx.strokeRect(hintX, hintY, hintW, hintH);
          
          // Draw hint box shadow
          ctx.fillStyle = 'rgba(0,0,0,1)';
          ctx.fillRect(hintX, hintY + hintH, hintW, 4);
          ctx.fillRect(hintX + hintW, hintY, 4, hintH + 4);
          
          // Draw hint text
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 16px "PixelFont", "Courier New", monospace';
          ctx.fillText('CONTROLS', hintX + 12, hintY + 24);
          
          ctx.font = '14px "PixelFont", "Courier New", monospace';
          ctx.fillText('A D : Move', hintX + 12, hintY + 48);
          ctx.fillText('W / Space : Jump', hintX + 12, hintY + 68);
          ctx.fillText('Shift : Run', hintX + 12, hintY + 88);
          
          ctx.font = '12px "PixelFont", "Courier New", monospace';
          ctx.fillStyle = 'rgba(255,255,255,0.8)';
          ctx.fillText('Collect all coins', hintX + 12, hintY + 110);
          ctx.restore();
          
          // HUD: Draw RESTART button (right-top corner)
          ctx.save();
          const btnX = VW - 120;
          const btnY = 12;
          const btnW = 108;
          const btnH = 36;
          
          // Draw button background
          ctx.fillStyle = 'rgba(0,0,0,0.8)';
          ctx.fillRect(btnX, btnY, btnW, btnH);
          
          // Draw button border
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 2;
          ctx.strokeRect(btnX, btnY, btnW, btnH);
          
          // Draw button shadow
          ctx.fillStyle = 'rgba(0,0,0,1)';
          ctx.fillRect(btnX, btnY + btnH, btnW, 4);
          ctx.fillRect(btnX + btnW, btnY, 4, btnH + 4);
          
          // Draw button text
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 16px "PixelFont", "Courier New", monospace';
          ctx.textAlign = 'center';
          ctx.fillText('RESTART', btnX + btnW/2, btnY + 24);
          ctx.textAlign = 'left';
          ctx.restore();
          
          // HUD: Display coin collection progress (top left)
          const collectedCoins = collectibles.filter(c=>c.collected).length;
          const showCount = coinAnimation ? displayedCoinCount : collectedCoins;
          
          ctx.save();
          // Draw progress box
          const boxX = 20;
          const boxY = 20;
          const boxW = 280;
          const boxH = 80;
          
          ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
          ctx.fillRect(boxX, boxY, boxW, boxH);
          ctx.strokeStyle = '#cccccc';
          ctx.lineWidth = 3;
          ctx.strokeRect(boxX, boxY, boxW, boxH);
          
          // Title
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 20px "PixelFont", monospace';
          ctx.textAlign = 'left';
          ctx.fillText('Word Puzzles', boxX + 15, boxY + 30);
          
          // Coin count with animation
          ctx.fillStyle = showCount >= 3 ? '#ffffff' : '#cccccc';
          ctx.font = 'bold 28px "PixelFont", monospace';
          
          // Add glow effect when count changes
          if (coinAnimation && displayedCoinCount > 0) {
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#cccccc';
          }
          
          ctx.fillText(`${showCount} / 3`, boxX + 15, boxY + 65);
          
          // Show current input if active
          if (showingPrompt && currentInput.length > 0) {
            ctx.fillStyle = '#cccccc';
            ctx.font = '16px "PixelFont", monospace';
            ctx.textAlign = 'left';
            ctx.fillText(`Input: ${currentInput}`, boxX + 15, boxY + boxH + 25);
          }
          
          ctx.restore();
          
          // Draw coin collection animation
          if (coinAnimation) {
            const now = performance.now();
            const elapsed = now - coinAnimation.startTime;
            const progress = Math.min(elapsed / COIN_ANIM_DURATION, 1);
            
            // Easing function (ease-in-out)
            const easeProgress = progress < 0.5 
              ? 2 * progress * progress 
              : 1 - Math.pow(-2 * progress + 2, 2) / 2;
            
            // Target position (top left HUD)
            const targetX = 150;
            const targetY = 55;
            
            // Current position
            const currentX = coinAnimation.startX + (targetX - coinAnimation.startX) * easeProgress;
            const currentY = coinAnimation.startY + (targetY - coinAnimation.startY) * easeProgress;
            
            // Size animation (shrinks as it flies)
            const size = 24 * (1 - easeProgress * 0.3);
            
            // Opacity (appears in center at the end)
            const opacity = progress < 0.8 ? 1 : 1 - (progress - 0.8) / 0.2;
            
            // Draw flying coin
            ctx.save();
            ctx.globalAlpha = opacity;
            
            // Glow
            const pulse = Math.sin(now * 0.01) * 0.3 + 0.7;
            ctx.shadowBlur = 30 * pulse;
            ctx.shadowColor = 'rgba(200, 200, 200, 0.8)';
            
            if (coinImage) {
              // Use coin image for animation
              const frameCount = 8;
              const frameIndex = Math.floor((now * 0.008) % frameCount);
              const frameW = coinImage.width / frameCount;
              const frameH = coinImage.height;
              const coinSize = size * 2; // Match size
              
              ctx.drawImage(
                coinImage,
                frameIndex * frameW, 0, frameW, frameH,
                currentX - coinSize/2, currentY - coinSize/2, coinSize, coinSize
              );
            } else {
              // Fallback: draw circle
              ctx.fillStyle = '#ffd700';
              ctx.beginPath();
              ctx.arc(currentX, currentY, size, 0, Math.PI * 2);
              ctx.fill();
              
              ctx.strokeStyle = '#ffed4e';
              ctx.lineWidth = 3;
              ctx.stroke();
            }
            
            ctx.restore();
            
            // Update displayed count smoothly
            if (progress >= 0.8) {
              const countProgress = (progress - 0.8) / 0.2;
              displayedCoinCount = Math.floor(coinAnimation.targetCount * countProgress + (coinAnimation.targetCount - 1) * (1 - countProgress));
            }
            
            // Show "Collected!" text in center
            if (progress >= 0.7 && progress < 1.0) {
              const textOpacity = progress < 0.85 ? (progress - 0.7) / 0.15 : 1 - (progress - 0.85) / 0.15;
              ctx.save();
              ctx.globalAlpha = textOpacity;
              ctx.fillStyle = '#ffffff';
              ctx.font = 'bold 48px "PixelFont", monospace';
              ctx.textAlign = 'center';
              ctx.shadowBlur = 20;
              ctx.shadowColor = 'rgba(200, 200, 200, 0.8)';
              ctx.fillText('Collected!', VW / 2, VH / 2);
              ctx.restore();
            }
            
            // End animation
            if (progress >= 1) {
              coinAnimation = null;
              displayedCoinCount = coinAnimation ? coinAnimation.targetCount : collectibles.filter(c=>c.collected).length;
            }
          }
          
          // if reveal in progress draw reveal overlay elements
          drawReveal();
        }

        let last = performance.now();
        let running = false;
        function loop(now){
          try {
            const dt = now - last; last = now;
            animTick += (player.anim ? dt/140 : dt/800); // faster when walking
            update(dt);
            draw();
            updateNarrativeAnim(now);
            if(running) requestAnimationFrame(loop);
            else last = performance.now();
          } catch(err) {
            console.error('Error in game loop:', err);
            running = false;
            alert('Game error: ' + err.message + '\nCheck console for details');
          }
        }

        // particle + reveal animation state
        let revealT = 0;
        function onComplete(){
          // animate reveal instead of immediate overlay
          revealT = 1; // start reveal timeline
          try{ if(window.SpliceMain && window.SpliceMain.reportLevelComplete){ window.SpliceMain.reportLevelComplete(1); } }catch(e){}
          const s = JSON.parse(localStorage.getItem('splicing_state_v1')||'{}');
          s.droppedKeys = s.droppedKeys || [];
          if(!s.droppedKeys.includes('1030')) s.droppedKeys.push('1030');
          localStorage.setItem('splicing_state_v1', JSON.stringify(s));
        }

        // simple pixel font (5x7) for large pixel text rendering
        const PIXEL_FONT = {
          '0': [0x7C,0xC6,0xCE,0xD6,0xE6,0xC6,0x7C],
          '1': [0x18,0x38,0x18,0x18,0x18,0x18,0x7E],
          '2': [0x7C,0xC6,0x06,0x1C,0x30,0x66,0xFE],
          '3': [0x7C,0xC6,0x06,0x3C,0x06,0xC6,0x7C]
        };

        function drawPixelText(str, sx, sy, scale, color){
          const gap = 1;
          let x = sx;
          for(const ch of String(str)){
            const pattern = PIXEL_FONT[ch] || PIXEL_FONT['0'];
            for(let row=0; row<pattern.length; row++){
              const bits = pattern[row];
              for(let col=0; col<8; col++){
                if((bits >> (7-col)) & 1){
                  ctx.fillStyle = color;
                  ctx.fillRect(x + col*scale, sy + row*scale, scale, scale);
                }
              }
            }
            x += (8*scale) + gap*scale;
          }
        }

        // draw reveal overlay when revealT>0
        function drawReveal(){
          if(revealT <= 0) return;
          // ease and progress
          revealT += 0.02;
          const p = Math.min(1, revealT);
          // darken background with easing
          ctx.fillStyle = `rgba(10,10,10,${0.6 * p})`;
          ctx.fillRect(0,0,VW,VH);
          // draw large pixel text for key in center
          const text = '1030';
          const scale = 12;
          const totalW = text.length * (8*scale) + (text.length-1)*scale;
          const sx = Math.floor((VW - totalW)/2);
          const sy = Math.floor(VH/2 - (7*scale)/2 - 20);
          drawPixelText(text, sx, sy, scale, '#ffffff');
          // small caption
          ctx.fillStyle = '#fff';
          ctx.font = '20px monospace'; ctx.textAlign = 'center';
          ctx.fillText('Dropped key', VW/2, sy - 10);
          // after fully revealed, show overlay button
          if(p >= 1){ document.getElementById('completeOverlay').style.display = 'flex'; revealT = 0; }
        }

        // ------------------ ambient audio (layered) ------------------
        let ambientNodes = null;
        function startAmbient(){
          ensureAudio(); if(!audioCtx) return;
          if(ambientNodes) return;
          const master = audioCtx.createGain(); master.gain.value = 0.0;
          // gentle global lowpass for warmth
          const lp = audioCtx.createBiquadFilter(); lp.type = 'lowpass'; lp.frequency.value = 1200; lp.Q.value = 0.7;
          master.connect(lp); lp.connect(audioCtx.destination);

          // pad layer 1 (slow sine)
          const pad1 = audioCtx.createOscillator(); pad1.type = 'sine'; pad1.frequency.value = 90;
          const pad1G = audioCtx.createGain(); pad1G.gain.value = 0.0; pad1.connect(pad1G); pad1G.connect(master);

          // pad layer 2 (detuned saw-like via two slightly detuned triangle oscs)
          const pad2a = audioCtx.createOscillator(); pad2a.type = 'triangle'; pad2a.frequency.value = 220;
          const pad2b = audioCtx.createOscillator(); pad2b.type = 'triangle'; pad2b.frequency.value = 222.5;
          const pad2G = audioCtx.createGain(); pad2G.gain.value = 0.0; pad2a.connect(pad2G); pad2b.connect(pad2G); pad2G.connect(master);

          // subtle bell/ding occasional (started/stopped by random timer)
          const bell = audioCtx.createOscillator(); bell.type = 'sine'; bell.frequency.value = 880;
          const bellG = audioCtx.createGain(); bellG.gain.value = 0.0; bell.connect(bellG); bellG.connect(master);

          // ambient slow LFO to modulate pad gains
          const lfo = audioCtx.createOscillator(); lfo.type = 'sine'; lfo.frequency.value = 0.08;
          const lfoG = audioCtx.createGain(); lfoG.gain.value = 0.08; lfo.connect(lfoG);
          // connect lfo to pad gains' gain values via setValueAtTime in interval

          pad1.start(); pad2a.start(); pad2b.start(); bell.start(); lfo.start();

          // ramp in gains slowly
          const t = audioCtx.currentTime;
          pad1G.gain.linearRampToValueAtTime(0.06, t + 3.5);
          pad2G.gain.linearRampToValueAtTime(0.04, t + 4.0);
          master.gain.value = 1.0; // used as control routing through lp

          // occasional bell hits
          ambientNodes = {master, lp, pad1, pad1G, pad2a, pad2b, pad2G, bell, bellG, lfo, lfoG};

          // lfo-based modulation loop (since direct param automation can be limited)
          ambientNodes._modInt = setInterval(()=>{
            const now = audioCtx.currentTime;
            const v = (Math.sin(now * 0.08) + 1) * 0.5; // 0..1
            // use it to subtly modulate pad gains
            pad1G.gain.setTargetAtTime(0.03 + v*0.035, now, 1.2);
            pad2G.gain.setTargetAtTime(0.02 + (1-v)*0.03, now, 1.6);
            // lowpass gentle sweep
            lp.frequency.setTargetAtTime(1000 + v*800, now, 2.2);
            // occasional bell
            if(Math.random() < 0.06){
              const g = audioCtx.createGain(); g.gain.value = 0.0001; bell.connect(g); g.connect(audioCtx.destination);
              const now2 = audioCtx.currentTime;
              g.gain.setValueAtTime(0.0001, now2);
              g.gain.exponentialRampToValueAtTime(0.12, now2 + 0.02);
              g.gain.exponentialRampToValueAtTime(0.0001, now2 + 1.0);
              setTimeout(()=>{ try{ g.disconnect(); }catch(e){} }, 1500);
            }
          }, 420);

          // melodic motif (simple pure-music loop)
          const melody = [220, 246.94, 261.63, 196]; // A3, B3, C4, G3
          let mi = 0;
          ambientNodes._melodyInt = setInterval(()=>{
            const f = melody[mi % melody.length] * (Math.random() < 0.2 ? 0.5 : 1);
            playAmbientNote(f, 0.9, 0.08);
            mi++;
          }, 900);
        }

        function playAmbientNote(freq, dur=0.9, gain=0.06){
          if(!audioCtx) return;
          const o = audioCtx.createOscillator(); o.type = 'sine'; o.frequency.value = freq;
          const g = audioCtx.createGain(); g.gain.value = 0.0001;
          // gentle lowpass per-note
          const f = audioCtx.createBiquadFilter(); f.type = 'lowpass'; f.frequency.value = 2000;
          o.connect(g); g.connect(f); f.connect(audioCtx.destination);
          o.start();
          const now = audioCtx.currentTime;
          g.gain.exponentialRampToValueAtTime(gain, now + 0.02);
          g.gain.exponentialRampToValueAtTime(0.0001, now + dur);
          o.stop(now + dur + 0.05);
        }

        function stopAmbient(){
          if(!ambientNodes) return;
          clearInterval(ambientNodes._modInt);
          const now = audioCtx.currentTime;
          try{
            ambientNodes.pad1G.gain.linearRampToValueAtTime(0.0001, now + 1.2);
            ambientNodes.pad2G.gain.linearRampToValueAtTime(0.0001, now + 1.6);
            ambientNodes.lp.frequency.linearRampToValueAtTime(400, now + 1.6);
          }catch(e){}
          setTimeout(()=>{
            try{ ambientNodes.pad1.stop(); ambientNodes.pad2a.stop(); ambientNodes.pad2b.stop(); ambientNodes.bell.stop(); ambientNodes.lfo.stop(); }catch(e){}
            ambientNodes = null;
          }, 1600);
        }

        // ------------------ scripted events ------------------
        const events = [
          {type:'walk', speed:60, duration:5200},
          {type:'pause', duration:2600, text:'The path follows the river quiet as an old mirror'},
          {type:'walk', speed:70, duration:6800},
          {type:'pause', duration:3000, text:'Tree shadows drift past whispers in the distance'},
          {type:'walk', speed:80, duration:9000},
          {type:'pause', duration:3200, text:'Gray sky holds the warmth of afternoon'},
          {type:'walk', speed:90, duration:10000},
          {type:'pause', duration:3600, text:'Walk slowly leave time for small things along the way'}
        ];
        let evIndex = 0; let evTimer = null; let currentEvent = null;

        // scenic decorations and proximity triggers
        const scenery = [
          // Early section - introduce the scene
          {x: 800, type: 'item6', scale: 0.25, yOffset: 50, text: 'A small stone rests quietly in the grass'},
          {x: 1400, type: 'cow_tree', scale: 0.45, yOffset: 60, text: 'A cow grazes peacefully under the old tree'},
          
          // Mid section - around first collectible (x=2400)
          {x: 3000, type: 'house', scale: 0.35, yOffset: 100, text: 'An abandoned house stands alone in silence'},
          
          // Mid-late section - around second collectible (x=5600)
          {x: 4200, type: 'cow_tree', scale: 0.45, yOffset: 60, text: 'Tree shadows drift past whispers in the distance'},
          {x: 5000, type: 'item6', scale: 0.25, yOffset: 50, text: 'Weathered rocks mark the forgotten path'},
          
          // Late section - around third collectible (x=8800)
          {x: 7400, type: 'house', scale: 0.35, yOffset: 100, text: 'Time has worn these walls to memory'},
          {x: 8200, type: 'cow_tree', scale: 0.45, yOffset: 60, text: 'The cow and tree wait together unchanged'},
          {x: 9400, type: 'item6', scale: 0.25, yOffset: 50, text: 'Small things left behind by travelers'}
        ];
        const sceneryTriggered = new Set();
        // inline SVG sprites (grayscale) for richer scenery without external assets
        const SPRITE_IMAGES = {};
        (function(){
          const makeURI = s => 'data:image/svg+xml;utf8,' + encodeURIComponent(s);

          // tree svg
          const treeSVG = `
            <svg xmlns='http://www.w3.org/2000/svg' width='180' height='160' viewBox='0 0 180 160'>
              <rect width='100%' height='100%' fill='none'/>
              <g fill='#dcdcdc'>
                <ellipse cx='90' cy='50' rx='70' ry='34' />
                <ellipse cx='60' cy='34' rx='40' ry='26' />
                <ellipse cx='120' cy='34' rx='40' ry='26' />
              </g>
              <g fill='#8b6b3a'>
                <rect x='82' y='70' width='16' height='68' rx='3'/>
              </g>
              <g fill='#bfbfbf' opacity='0.9'>
                <ellipse cx='90' cy='40' rx='20' ry='12'/>
              </g>
            </svg>
          `;

          // bench svg
          const benchSVG = `
            <svg xmlns='http://www.w3.org/2000/svg' width='120' height='64' viewBox='0 0 120 64'>
              <rect width='120' height='64' fill='none'/>
              <rect x='6' y='26' width='108' height='12' fill='#e6e6e6' rx='3'/>
              <rect x='10' y='36' width='8' height='18' fill='#9f9f9f'/>
              <rect x='102' y='36' width='8' height='18' fill='#9f9f9f'/>
              <rect x='14' y='28' width='92' height='6' fill='#cfcfcf' rx='2'/>
            </svg>
          `;

          // building (cabin) svg
          const buildingSVG = `
            <svg xmlns='http://www.w3.org/2000/svg' width='300' height='160' viewBox='0 0 300 160'>
              <rect width='100%' height='100%' fill='none'/>
              <rect x='20' y='48' width='260' height='92' fill='#e6e6e6' rx='4'/>
              <rect x='30' y='58' width='60' height='60' fill='#cfcfcf'/>
              <rect x='90' y='58' width='120' height='12' fill='#dcdcdc'/>
              <rect x='222' y='58' width='28' height='40' fill='#cfcfcf'/>
              <rect x='90' y='82' width='120' height='12' fill='#d0d0d0'/>
              <path d='M20 48 L150 12 L280 48 Z' fill='#d9d9d9'/>
            </svg>
          `;

          // sign svg
          const signSVG = `
            <svg xmlns='http://www.w3.org/2000/svg' width='100' height='80' viewBox='0 0 100 80'>
              <rect width='100' height='80' fill='none'/>
              <rect x='46' y='8' width='8' height='56' fill='#bfbfbf'/>
              <rect x='56' y='18' width='36' height='16' fill='#ffffff' rx='2'/>
              <rect x='62' y='22' width='24' height='8' fill='#d0d0d0' rx='1'/>
            </svg>
          `;

          // lamp svg
          const lampSVG = `
            <svg xmlns='http://www.w3.org/2000/svg' width='60' height='140' viewBox='0 0 60 140'>
              <rect width='60' height='140' fill='none'/>
              <rect x='26' y='30' width='8' height='80' fill='#8b8b8b' rx='2'/>
              <rect x='18' y='18' width='24' height='18' fill='#fff6d6' rx='3'/>
              <rect x='22' y='22' width='16' height='10' fill='#f7e9c8' rx='2'/>
            </svg>
          `;

          const pairs = {tree:treeSVG, bench:benchSVG, building:buildingSVG, sign:signSVG, lamp:lampSVG};
          Object.keys(pairs).forEach(k=>{
            const im = new Image(); im.onload = ()=>{ SPRITE_IMAGES[k] = im; };
            im.onerror = ()=>{ SPRITE_IMAGES[k] = null; };
            im.src = makeURI(pairs[k]);
          });
        })();

        // --- user asset loader (direct load, no conversion - assets are already monochrome) ---
        // Simple image loader
        function loadImage(path, callback){
          const im = new Image();
          im.onload = ()=>{ callback(im); };
          im.onerror = ()=>{ callback(null); };
          im.src = path;
        }

        // Player sprite sheet state
        let playerWalkSheet = null;
        let playerIdleSheet = null;
        let playerRunSheet = null;
        const playerFrameW = 48; // typical frame width (adjust if needed)
        const playerFrameH = 48; // typical frame height

        // Background - single pre-composed image
        let compositeBackground = null;

        // Image loading counter
        let loadedImages = 0;
        let totalImages = 3; // Walk, Idle, Run
        
        function imageLoaded(){
          loadedImages++;
          console.log(`Loaded ${loadedImages}/${totalImages} player sprites`);
        }

        // Load player walk spritesheet
        loadImage('./assets/player/Walk.png', (img)=>{
          if(img){
            playerWalkSheet = img;
            imageLoaded();
          }
        });

        // Load player idle spritesheet
        loadImage('./assets/player/Idle.png', (img)=>{ 
          if(img){
            playerIdleSheet = img; 
            imageLoaded();
          }
        });

        // Load player run spritesheet
        loadImage('./assets/player/Run.png', (img)=>{ 
          if(img){
            playerRunSheet = img; 
            imageLoaded();
          }
        });

        // Load collectible image (spinning coin spritesheet)
        let coinImage = null;
        loadImage('./Spinning Coin.png', (img)=>{ if(img) coinImage = img; });

        // Load scenery assets (foreground decorations)
        const sceneryAssets = {
          house: null,
          cow_tree: null,
          item6: null,
          item7: null
        };

        loadImage('./assets/scenery/house.png', (img)=>{ if(img) sceneryAssets.house = img; });
        loadImage('./assets/scenery/cow and tree.png', (img)=>{ if(img) sceneryAssets.cow_tree = img; });
        loadImage('./assets/scenery/6.png', (img)=>{ if(img) sceneryAssets.item6 = img; });
        loadImage('./assets/scenery/7.png', (img)=>{ if(img) sceneryAssets.item7 = img; });

        // Load single pre-composed background (already monochrome)
        loadImage('./assets/backgrounds/background/pre.png', (img) => {
          if(img){
            compositeBackground = img;
            console.log('Background ready:', compositeBackground.width, 'x', compositeBackground.height);
            // Update ground positions after background loads
            setTimeout(updateGroundPositions, 100);
          }
        });

        function showNarrative(txt, dur){
          const el = document.getElementById('narrative'); const content = document.getElementById('narrativeText');
          
          // Clear any existing narrative timer
          if(narrativeTimer) {
            clearTimeout(narrativeTimer);
            narrativeTimer = null;
          }
          
          if(!txt){ el.classList.remove('show'); narrativeSpans = []; setTimeout(()=>{ el.style.display = 'none'; }, 420); return; }
          
          // Split into words (not characters) for independent floating
          content.innerHTML = '';
          const wrap = document.createElement('div'); wrap.className = 'card';
          
          // Split text into words - simpler now, just for spacing
          const words = txt.split(/\s+/);
          words.forEach((word, idx) => {
            if(word.trim().length === 0) return;
            
            wrap.appendChild(document.createTextNode(word));
            
            // Add space between words (except last one)
            if(idx < words.length - 1) {
              wrap.appendChild(document.createTextNode(' '));
            }
          });
          
          content.appendChild(wrap);
          el.style.display = 'block'; 
          setTimeout(()=>{ el.classList.add('show'); }, 20);
          
          if(dur) {
            narrativeTimer = setTimeout(()=>{ 
              el.classList.remove('show'); 
              narrativeTimer = null;
              setTimeout(()=>{ el.style.display = 'none'; }, 420); 
            }, dur);
          }
        }

        function startEventSequence(){ evIndex = 0; runNextEvent(); }
        function fadeScreenTo(op, ms, cb){
          const f = document.getElementById('fadeScreen'); f.style.transition = `opacity ${ms}ms ease`; f.style.opacity = String(op);
          if(cb) setTimeout(cb, ms + 10);
        }

        function runNextEvent(){
          if(evIndex >= events.length){ currentEvent = null; controlMode = 'player'; showNarrative(null); fadeScreenTo(0,400); return; }
          const ev = events[evIndex++]; currentEvent = ev;
          if(ev.type === 'walk'){
            // ensure screen clear, ambient present
            fadeScreenTo(0, 500);
            controlMode = 'auto'; player.vx = ev.speed;
            evTimer = setTimeout(()=>{ runNextEvent(); }, ev.duration);
            showNarrative(null);
          }else if(ev.type === 'pause'){
            // fade down a little, show narrative, then continue
            player.vx = 0;
            fadeScreenTo(0.32, 600, ()=>{
              showNarrative(ev.text || '', ev.duration);
              // keep fade during pause, then remove and continue
              evTimer = setTimeout(()=>{
                fadeScreenTo(0, 600, ()=>{ runNextEvent(); });
              }, ev.duration);
            });
          }
        }

        // narrative animation state
        let narrativeSpans = [];
        let narrativeStart = 0;
        let narrativeTimer = null; // Track narrative timeout to prevent duplicates
        function updateNarrativeAnim(now){
          // No animation needed - just fade in/out handled by CSS transition
          return;
        }

        document.getElementById('overlayClose').addEventListener('click', ()=>{
          document.getElementById('completeOverlay').style.display = 'none';
        });

        // start overlay handling
        const startOverlay = document.getElementById('startOverlay');
        const startBtn = document.getElementById('startBtn');
        // Auto-walk + narrative mode (The Longest Road on Earth style)
        let controlMode = 'auto'; // 'auto' | 'player'
        function startGame(){
          console.log('Game starting...');
          try {
            startOverlay.style.display = 'none';
            running = true; 
            last = performance.now(); 
            requestAnimationFrame(loop);
            if('ontouchstart' in window) document.getElementById('touchControls').style.display = 'flex';
            // start ambient audio and scripted events
            if (typeof startAmbient === 'function') startAmbient();
            if (typeof startEventSequence === 'function') startEventSequence();
            console.log('Game started successfully');
          } catch(err) {
            console.error('Error starting game:', err);
            alert('Error: ' + err.message);
          }
        }
        startBtn.addEventListener('click', startGame);
        window.addEventListener('keydown', (e)=>{ if(e.key === 'Enter' && !running) startGame(); });

  // touch control wiring
        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');
        const jumpBtn = document.getElementById('jumpBtn');
        if(leftBtn){
          leftBtn.addEventListener('pointerdown', ()=>{ keys['ArrowLeft'] = true; });
          leftBtn.addEventListener('pointerup', ()=>{ keys['ArrowLeft'] = false; });
          leftBtn.addEventListener('pointercancel', ()=>{ keys['ArrowLeft'] = false; });
        }
        if(rightBtn){
          rightBtn.addEventListener('pointerdown', ()=>{ keys['ArrowRight'] = true; });
          rightBtn.addEventListener('pointerup', ()=>{ keys['ArrowRight'] = false; });
          rightBtn.addEventListener('pointercancel', ()=>{ keys['ArrowRight'] = false; });
        }
        if(jumpBtn){
          jumpBtn.addEventListener('pointerdown', ()=>{ if(player.onGround){ player.vy = JUMP_V; player.onGround = false; playStep(); } });
        }

  // Canvas click handler for RESTART button and movement
  canvas.addEventListener('pointerdown', (e)=>{ 
    // Get canvas bounding rect to calculate click position
    const rect = canvas.getBoundingClientRect();
    const scaleX = VW / rect.width;
    const scaleY = VH / rect.height;
    const clickX = (e.clientX - rect.left) * scaleX;
    const clickY = (e.clientY - rect.top) * scaleY;
    
    // Check if clicked on RESTART button (right-top corner)
    const btnX = VW - 120;
    const btnY = 12;
    const btnW = 108;
    const btnH = 36;
    
    if(clickX >= btnX && clickX <= btnX + btnW && clickY >= btnY && clickY <= btnY + btnH){
      // Restart the game
      window.location.reload();
      return;
    }
    
    // Original movement code
    if(controlMode === 'player'){ 
      keys['ArrowRight'] = true; 
      setTimeout(()=>{ keys['ArrowRight'] = false; }, 200); 
    } else { 
      /* in auto mode, minor nudge */ 
      player.x += 8; 
    } 
  });

  // don't start until user presses start
      })();
    </script>
  </body>
</html>
