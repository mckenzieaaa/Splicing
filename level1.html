<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Level 1 — 黑白像素</title>
    <link rel="stylesheet" href="./style.css">
    <style>
      .hud{margin-top:8px;font-size:14px}
      #game-wrap{display:flex;gap:16px;align-items:flex-start}
      #lvl1{image-rendering:pixelated;border:2px solid #222;background:#fff}
      .overlay{position:fixed;left:0;top:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center}
      .msg{background:#fff;padding:18px;border:4px solid #000}
    </style>
  </head>
  <body>
    <main class="container">
      <h1>Level 1 — 黑白像素</h1>
      <div id="game-wrap">
        <canvas id="lvl1" width="768" height="432"></canvas>
        <div>
          <div class="hud">
            <p>控制：方向键 / WASD</p>
            <p>目标：收集白色“胶囊”（钥匙）以完成关卡并获得掉落码</p>
            <p>掉落码：会在通关时自动交给主界面（或显示在提示里）</p>
          </div>
          <div style="margin-top:16px"><a href="index.html">返回主界面</a></div>
        </div>
      </div>
    </main>

    <div id="completeOverlay" class="overlay" style="display:none">
      <div class="msg">
        <h2>已完成 Level 1</h2>
        <p>掉落 key: <strong>1030</strong></p>
        <p>请回到主界面并在主线 numeric key 输入框中输入该 key 以解锁下一关。</p>
        <button id="overlayClose">知道了</button>
      </div>
    </div>

    <script>
      // Small monochrome tile game prototype
      (function(){
        const canvas = document.getElementById('lvl1');
        const ctx = canvas.getContext('2d');
        const TILE = 16; // tile size in device pixels
        const COLS = Math.floor(canvas.width / TILE); // 48
        const ROWS = Math.floor(canvas.height / TILE); // 27

        // palette
        const COLOR = { bg:'#ffffff', floor:'#dddddd', wall:'#222222', player:'#000000', item:'#ffffff' };

        // simple map: 0 floor, 1 wall, 2 item
        const map = new Array(ROWS).fill(0).map(()=>new Array(COLS).fill(0));

        // create border walls
        for(let r=0;r<ROWS;r++){
          for(let c=0;c<COLS;c++){
            if(r===0||r===ROWS-1||c===0||c===COLS-1) map[r][c]=1;
          }
        }

        // add some interior obstacles
        for(let r=4;r<ROWS-4;r+=4){
          for(let c=6;c<COLS-6;c+=8){
            map[r][c]=1;
            if(Math.random()>0.6) map[r][c+1]=1;
          }
        }

        // place an item (the 'key') somewhere reachable
        const itemPos = {r: Math.max(2, Math.floor(ROWS/2)), c: Math.max(2, Math.floor(COLS*0.75))};
        map[itemPos.r][itemPos.c] = 2;

        // player
        const player = {r:2, c:2};

        // tiny 16x16 pixel sprite for player (monochrome) — pattern as 16 strings of '0'/'1'
        const SPRITE = [
          '0000001100000000',
          '0000011110000000',
          '0000111111000000',
          '0001111111100000',
          '0011111111110000',
          '0011111111110000',
          '0111111111111000',
          '0111101110111000',
          '0111101110111000',
          '0111111111111000',
          '0011110011110000',
          '0011100001110000',
          '0001100000110000',
          '0000110001100000',
          '0000011110000000',
          '0000000000000000'
        ];

        let keysDown = {};

        window.addEventListener('keydown', e=>{ keysDown[e.key] = true; e.preventDefault(); });
        window.addEventListener('keyup', e=>{ keysDown[e.key] = false; });

        function canMoveTo(r,c){
          if(r<0||r>=ROWS||c<0||c>=COLS) return false;
          return map[r][c] !== 1;
        }

        let collected = false;

        function update(){
          let moved = false;
          if((keysDown['ArrowUp']||keysDown['w']||keysDown['W'])){ if(canMoveTo(player.r-1, player.c)){ player.r--; moved=true; }}
          else if((keysDown['ArrowDown']||keysDown['s']||keysDown['S'])){ if(canMoveTo(player.r+1, player.c)){ player.r++; moved=true; }}
          else if((keysDown['ArrowLeft']||keysDown['a']||keysDown['A'])){ if(canMoveTo(player.r, player.c-1)){ player.c--; moved=true; }}
          else if((keysDown['ArrowRight']||keysDown['d']||keysDown['D'])){ if(canMoveTo(player.r, player.c+1)){ player.c++; moved=true; }}

          // check item pickup
          if(map[player.r][player.c] === 2){
            map[player.r][player.c] = 0; collected = true; onComplete();
          }
        }

        function drawTile(r,c){
          const t = map[r][c];
          if(t===1){ ctx.fillStyle = COLOR.wall; }
          else if(t===2){ ctx.fillStyle = COLOR.item; }
          else { ctx.fillStyle = COLOR.floor; }
          ctx.fillRect(c*TILE, r*TILE, TILE, TILE);
          // tile border subtle
          ctx.strokeStyle = '#bbbbbb';
          ctx.strokeRect(c*TILE, r*TILE, TILE, TILE);
        }

        function draw(){
          // background
          ctx.fillStyle = COLOR.bg; ctx.fillRect(0,0,canvas.width,canvas.height);

          // tiles
          for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) drawTile(r,c);

          // draw player sprite (16x16)
          const px = player.c * TILE;
          const py = player.r * TILE;
          for(let y=0;y<16;y++){
            const row = SPRITE[y];
            for(let x=0;x<16;x++){
              if(row[x] === '1'){
                ctx.fillStyle = COLOR.player;
                ctx.fillRect(px + x, py + y, 1, 1);
              }
            }
          }

          // HUD: draw item indicator
          ctx.fillStyle = '#000';
          ctx.font = '12px monospace';
          ctx.fillText('Items left: ' + (collected?0:1), 6, canvas.height - 8);
        }

        function loop(){ update(); draw(); requestAnimationFrame(loop); }

        function onComplete(){
          // show overlay and call main API if available
          document.getElementById('completeOverlay').style.display = 'flex';
          if(window.SpliceMain && window.SpliceMain.reportLevelComplete){
            window.SpliceMain.reportLevelComplete(1);
          } else {
            // fallback: save to localStorage
            const s = JSON.parse(localStorage.getItem('splicing_state_v1')||'{}');
            s.droppedKeys = s.droppedKeys || [];
            if(!s.droppedKeys.includes('1030')) s.droppedKeys.push('1030');
            localStorage.setItem('splicing_state_v1', JSON.stringify(s));
            console.log('Saved fallback dropped key 1030');
          }
        }

        document.getElementById('overlayClose').addEventListener('click', ()=>{
          document.getElementById('completeOverlay').style.display = 'none';
        });

        // start game loop
        requestAnimationFrame(loop);
      })();
    </script>
  </body>
</html>
