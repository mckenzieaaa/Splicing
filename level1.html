<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Level 1 — 黑白像素（Side-scroller）</title>
    <style>
      html,body{height:100%;margin:0;background:#111;color:#fff;overflow:hidden}
      canvas{image-rendering:pixelated;display:block;background:#e9e9e9}
      .overlay{position:fixed;left:0;top:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center}
      .msg{background:#fff;padding:18px;border:4px solid #000;color:#000}
      .hint{position:fixed;left:12px;top:12px;color:#ccc;font-family:monospace}
    </style>
  </head>
  <body>
    <canvas id="game"></canvas>
    <div class="hint">控制：← → 或 A D — 到达远处白色旗帜收集并完成关卡</div>

    <div id="completeOverlay" class="overlay" style="display:none">
      <div class="msg">
        <h2>已完成 Level 1</h2>
        <p>掉落 key: <strong>1030</strong></p>
        <p>回到主界面或在主页面输入该 key 以解锁下一关。</p>
        <div style="text-align:right;margin-top:8px"><button id="overlayClose">继续</button></div>
      </div>
    </div>

    <script>
      // Side-scrolling monochrome prototype inspired by calm walking games.
      (function(){
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');

        // virtual resolution (keeps 16px blocks alignment)
        const VW = 1920;
        const VH = 1088; // keep 16px grid -> 68 rows

        canvas.width = VW;
        canvas.height = VH;

        // scale canvas to fit window while preserving aspect
        function fit(){
          const scale = Math.min(window.innerWidth / VW, window.innerHeight / VH);
          canvas.style.width = Math.round(VW * scale) + 'px';
          canvas.style.height = Math.round(VH * scale) + 'px';
        }
        window.addEventListener('resize', fit);
        fit();

        // world
        const tile = 16; // 16px logical pixel
        const groundY = VH - 6 * tile; // ground baseline

        // player
        const player = { x: 120, y: groundY - 16, w:16, h:16, vx:0, onGround:true, dir:1, anim:0 };

        // camera
        let camX = 0;

        // controls
        const keys = {};
        window.addEventListener('keydown', e=>{ keys[e.key] = true; });
        window.addEventListener('keyup', e=>{ keys[e.key] = false; });

        // world features: parallax layers and a distant white flag as item
        const layers = [
          {color:'#dcdcdc', speed:0.1, y:200, h:200},
          {color:'#bfbfbf', speed:0.3, y:360, h:180},
          {color:'#9f9f9f', speed:0.6, y:520, h:220}
        ];

        const flag = { x: 3000, y: groundY - 48, w: 10, h: 48, collected:false };

        // walking sprite (16x16) monochrome frames — 4 subtle frames for smoother movement
        const SPRITES = [
          [
            '0000000000000000','0000011111000000','0000111111100000','0001111111110000','0011111111111000','0011111111111000','0111111111111100','0111101110111100','0111101110111100','0111111111111100','0011110011111000','0011100001111000','0001100000110000','0000110001100000','0000011110000000','0000000000000000'
          ],
          [
            '0000000000000000','0000011111000000','0000111111100000','0001111111110000','0011111111111000','0011111111111000','0111111111111100','0111011110111100','0111101110111000','0111111111111000','0011110011111000','0011100001111000','0001100000110000','0000110001100000','0000011110000000','0000000000000000'
          ],
          [
            '0000000000000000','0000011111000000','0000111111100000','0001111111110000','0011111111111000','0011111111111000','0111111111111100','0111101110111100','0111110110111100','0111111111111100','0011110011111000','0011100001111000','0001100000110000','0000110001100000','0000011110000000','0000000000000000'
          ],
          [
            '0000000000000000','0000011111000000','0000111111100000','0001111111110000','0011111111111000','0011111111111000','0111111111111100','0111101110111100','0111101110111100','0111111111111100','0011110011111000','0011100001111000','0001100000110000','0000110001100000','0000011110000000','0000000000000000'
          ]
        ];

        let animTick = 0;

        function update(dt){
          // input
          const left = keys['ArrowLeft'] || keys['a'] || keys['A'];
          const right = keys['ArrowRight'] || keys['d'] || keys['D'];

          if(left){ player.vx = -140; player.dir = -1; player.anim = 1; }
          else if(right){ player.vx = 140; player.dir = 1; player.anim = 1; }
          else { player.vx = 0; player.anim = 0; }

          // apply velocity
          player.x += player.vx * (dt/1000);

          // clamp
          if(player.x < 40) player.x = 40;

          // camera follows player with easing, clamp min at 0
          const targetCam = Math.max(0, player.x - VW*0.35);
          camX += (targetCam - camX) * Math.min(1, dt/200);

          // check flag collection
          if(!flag.collected && player.x + player.w/2 >= flag.x){
            flag.collected = true;
            onComplete();
          }
        }

        function draw(){
          // clear
          ctx.fillStyle = '#f4f4f4'; ctx.fillRect(0,0,VW,VH);

          // draw layers (parallax)
          layers.forEach(layer=>{
            const px = - (camX * layer.speed) % (VW + 200);
            ctx.fillStyle = layer.color;
            // repeat rectangles across the width
            for(let x = px - 200; x < VW; x += 400){
              ctx.fillRect(x, layer.y, 360, layer.h);
            }
          });

          // ground
          ctx.fillStyle = '#d0d0d0';
          ctx.fillRect(0, groundY, VW, VH-groundY);

          // draw flag (item)
          if(!flag.collected){
            const fx = flag.x - camX;
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(fx, flag.y, 6, flag.h);
            // pennant
            ctx.fillRect(fx+6, flag.y+8, 14, 6);
          }

          // draw player at center-ish
          const px = Math.round(player.x - camX);
          const py = Math.round(player.y);
          // draw small shadow
          ctx.fillStyle = 'rgba(0,0,0,0.08)';
          ctx.fillRect(px-6, groundY+2, 28, 6);

          // draw sprite pixel-by-pixel (monochrome) with 4-frame animation
          const frameIndex = Math.floor(animTick) % SPRITES.length;
          const spriteData = SPRITES[frameIndex][0];
          for(let y=0;y<16;y++){
            const row = spriteData[y];
            for(let x=0;x<16;x++){
              if(row[x] === '1'){
                ctx.fillStyle = '#0a0a0a';
                if(player.dir === 1) ctx.fillRect(px + x, py + y, 1, 1);
                else ctx.fillRect(px + (15-x), py + y, 1, 1);
              }
            }
          }

          // HUD: small label
          ctx.fillStyle = '#000'; ctx.font = '14px monospace'; ctx.fillText('远处的旗帜会掉落 key', 12, 26);
        }

        let last = performance.now();
        function loop(now){
          const dt = now - last; last = now;
          animTick += (player.anim ? dt/140 : dt/800); // faster when walking
          update(dt);
          draw();
          requestAnimationFrame(loop);
        }

        // particle + reveal animation state
        let revealT = 0;
        function onComplete(){
          // animate reveal instead of immediate overlay
          revealT = 1; // start reveal timeline
          try{ if(window.SpliceMain && window.SpliceMain.reportLevelComplete){ window.SpliceMain.reportLevelComplete(1); } }catch(e){}
          const s = JSON.parse(localStorage.getItem('splicing_state_v1')||'{}');
          s.droppedKeys = s.droppedKeys || [];
          if(!s.droppedKeys.includes('1030')) s.droppedKeys.push('1030');
          localStorage.setItem('splicing_state_v1', JSON.stringify(s));
        }

        // draw reveal overlay when revealT>0
        function drawReveal(){
          if(revealT <= 0) return;
          // ease and progress
          revealT += 0.02;
          const p = Math.min(1, revealT);
          // darken background
          ctx.fillStyle = `rgba(10,10,10,${0.6 * p})`;
          ctx.fillRect(0,0,VW,VH);
          // draw large pixel text for key
          const text = '1030';
          ctx.fillStyle = '#fff';
          ctx.font = `${48 + Math.floor(40*p)}px monospace`;
          ctx.textAlign = 'center';
          ctx.fillText('Dropped key: ' + text, VW/2, VH/2);
          // after fully revealed, show overlay button
          if(p >= 1){ document.getElementById('completeOverlay').style.display = 'flex'; revealT = 0; }
        }

        document.getElementById('overlayClose').addEventListener('click', ()=>{
          document.getElementById('completeOverlay').style.display = 'none';
        });

        // allow click/tap to move right (mobile friendly)
        canvas.addEventListener('pointerdown', (e)=>{ keys['ArrowRight'] = true; setTimeout(()=>{ keys['ArrowRight'] = false; }, 200); });

        requestAnimationFrame(loop);
      })();
    </script>
  </body>
</html>
