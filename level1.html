<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Level 1 — 黑白像素（Side-scroller）</title>
    <style>
  html,body{height:100%;margin:0;background:#111;color:#fff;overflow:hidden}
  /* center the canvas and constrain its displayed size so it never overflows */
  canvas{image-rendering:pixelated;display:block;background:#e9e9e9;position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);max-width:100%;max-height:100%;box-shadow:0 0 0 1px rgba(0,0,0,0.1)}
      .overlay{position:fixed;left:0;top:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center}
      .msg{background:#fff;padding:18px;border:4px solid #000;color:#000}
      .hint{position:fixed;left:12px;top:12px;color:#ccc;font-family:monospace}
      .mute{position:fixed;right:12px;top:12px;background:rgba(0,0,0,0.5);color:#fff;padding:6px 10px;border-radius:6px;cursor:pointer;font-family:monospace}
      /* mobile controls */
      .controls{position:fixed;left:12px;bottom:12px;display:flex;gap:8px}
      .btn{width:64px;height:64px;border-radius:8px;background:rgba(0,0,0,0.35);display:flex;align-items:center;justify-content:center;color:#fff;font-weight:700;font-family:monospace;user-select:none}
      .startOverlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.6);z-index:20}
      .startBox{background:#fff;color:#000;padding:20px;border-radius:8px;border:4px solid #000;text-align:center}
      /* narrative card */
  .narrative{position:fixed;left:50%;top:8%;transform:translateX(-50%);z-index:25;pointer-events:none;opacity:0;transition:opacity 400ms ease}
  .narrative.show{opacity:1}
  /* floating translucent text - no box */
  .narrative .card{background:transparent;color:rgba(28,28,28,0.96);padding:6px 12px;border-radius:6px;border:0;display:inline-block;font-family:monospace;font-size:20px;text-shadow:0 2px 6px rgba(255,255,255,0.03)}
  .narrative .card span{display:inline-block;transition:transform 900ms cubic-bezier(.22,.9,.35,1),opacity 900ms ease}
  .narrative.show .card{ /* keep a very slow subtle float for the whole block */ transform-origin:center; animation:floaty 10s ease-in-out infinite}
  /* per-character random float handled by JS */
  @keyframes floaty{0%{transform:translateY(0)}50%{transform:translateY(-8px)}100%{transform:translateY(0)}}
      .fadeScreen{position:fixed;inset:0;background:#000;opacity:0;pointer-events:none;transition:opacity 600ms ease;z-index:30}
    </style>
  </head>
  <body>
    <canvas id="game"></canvas>
    <div class="hint">控制：← → / A D，跳跃：↑ / W / 空格 — 收集全部白色胶囊</div>
    <div id="muteBtn" class="mute">Mute</div>
    <div class="controls" id="touchControls" style="display:none">
      <div id="leftBtn" class="btn">◀</div>
      <div id="rightBtn" class="btn">▶</div>
      <div id="jumpBtn" class="btn">▲</div>
    </div>

    <div id="startOverlay" class="startOverlay">
      <div class="startBox">
        <h2>Level 1 — 黑白像素</h2>
        <p>按 Enter 开始游戏</p>
        <p>移动：← → / A D，跳跃：↑ / W / 空格</p>
        <button id="startBtn">开始</button>
      </div>
    </div>

  <div id="narrative" class="narrative" aria-hidden="true"><div class="card" id="narrativeText"></div></div>
  <div id="fadeScreen" class="fadeScreen"></div>

    <div id="completeOverlay" class="overlay" style="display:none">
      <div class="msg">
        <h2>已完成 Level 1</h2>
        <p>掉落 key: <strong>1030</strong></p>
        <p>回到主界面或在主页面输入该 key 以解锁下一关。</p>
        <div style="text-align:right;margin-top:8px"><button id="overlayClose">继续</button></div>
      </div>
    </div>

    <script>
      // Side-scrolling monochrome prototype inspired by calm walking games.
      (function(){
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');

        // virtual resolution (keeps 16px blocks alignment)
        const VW = 1920;
        const VH = 1088; // keep 16px grid -> 68 rows

        canvas.width = VW;
        canvas.height = VH;

        // scale canvas to fit window while preserving aspect
        function fit(){
          const scale = Math.min(window.innerWidth / VW, window.innerHeight / VH);
          canvas.style.width = Math.round(VW * scale) + 'px';
          canvas.style.height = Math.round(VH * scale) + 'px';
        }
        window.addEventListener('resize', fit);
        fit();

        // world
        const tile = 16; // 16px logical pixel
        const groundY = VH - 6 * tile; // ground baseline

        // visual / physics scale (increase to make everything larger on screen)
          const SPRITE_DRAW_SCALE = 4; // visual scale for sprite rendering (was 2)
          const PHYS_SCALE = SPRITE_DRAW_SCALE; // scale collision box to match visual size
          const VISUAL_SCALE = 4; // additional visual scale for non-physics elements (collectibles, decorations)
          // player (logical size defined here; y will be anchored to ground using scaled collision height)
          const player = { x: 120, y: 0, w:16, h:16, vx:0, onGround:true, dir:1, anim:0 };
          // ensure player visually sits on the ground according to PHYS_SCALE
          player.y = groundY - player.h * PHYS_SCALE;

        // camera
        let camX = 0;

  // controls
  const keys = {};
  window.addEventListener('keydown', e=>{ keys[e.key] = true; });
  window.addEventListener('keyup', e=>{ keys[e.key] = false; });
  // jump input should be edge-triggered; track key state for jump
  const jumpKeys = ['ArrowUp','w','W',' '];

  // world features: parallax layers and collectibles as items
        const layers = [
          {color:'#dcdcdc', speed:0.1, y:200, h:200},
          {color:'#bfbfbf', speed:0.3, y:360, h:180},
          {color:'#9f9f9f', speed:0.6, y:520, h:220}
        ];

        // platforms and collectibles
        const platforms = [
          {x:0, y:groundY, w:14000, h:6}
        ];

        const collectibles = [
          {x: 1600, y: groundY - 24, w:8, h:8, collected:false},
          {x: 3200, y: groundY - 40, w:8, h:8, collected:false},
          {x: 5200, y: groundY - 24, w:8, h:8, collected:false}
        ];

        const COLLECT_TARGET = collectibles.length;

  // walking sprite (16x16) monochrome frames — 6 subtle frames for smoother movement
  const SPRITES = [
          [
            '0000000000000000','0000011111000000','0000111111100000','0001111111110000','0011111111111000','0011111111111000','0111111111111100','0111101110111100','0111101110111100','0111111111111100','0011110011111000','0011100001111000','0001100000110000','0000110001100000','0000011110000000','0000000000000000'
          ],
          [
            '0000000000000000','0000011111000000','0000111111100000','0001111111110000','0011111111111000','0011111111111000','0111111111111100','0111011110111100','0111101110111000','0111111111111000','0011110011111000','0011100001111000','0001100000110000','0000110001100000','0000011110000000','0000000000000000'
          ],
          [
            '0000000000000000','0000011111000000','0000111111100000','0001111111110000','0011111111111000','0011111111111000','0111111111111100','0111101110111100','0111110110111100','0111111111111100','0011110011111000','0011100001111000','0001100000110000','0000110001100000','0000011110000000','0000000000000000'
          ],
          [
            '0000000000000000','0000011111000000','0000111111100000','0001111111110000','0011111111111000','0011111111111000','0111111111111100','0111101110111100','0111101110111100','0111111111111100','0011110011111000','0011100001111000','0001100000110000','0000110001100000','0000011110000000','0000000000000000'
          ]
        ];

  let animTick = 0;
  // physics
  const GRAV = 1200; // px/s^2
  const JUMP_V = -520; // px/s
        // audio
        let audioCtx = null;
        let muted = false;
        function ensureAudio(){
          if(audioCtx) return;
          try{ audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }catch(e){ audioCtx = null; }
        }
        function playTone(freq, time=0.08, type='sine', gain=0.08){
          if(muted) return;
          ensureAudio(); if(!audioCtx) return;
          const o = audioCtx.createOscillator();
          const g = audioCtx.createGain();
          o.type = type; o.frequency.value = freq;
          g.gain.value = gain;
          o.connect(g); g.connect(audioCtx.destination);
          o.start();
          g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + time);
          o.stop(audioCtx.currentTime + time + 0.02);
        }
        function playStep(){ playTone(200, 0.06, 'triangle', 0.03); }
        function playPickup(){ playTone(880, 0.18, 'sine', 0.12); }

        function update(dt){
          // track previous grounded state for proper jump edge detection
          const wasOnGround = !!player.onGround;
          // reset grounded state; will be set during collision check
          player.onGround = false;
          // input
          const left = keys['ArrowLeft'] || keys['a'] || keys['A'];
          const right = keys['ArrowRight'] || keys['d'] || keys['D'];

          if(left){ player.vx = -140; player.dir = -1; player.anim = 1; }
          else if(right){ player.vx = 140; player.dir = 1; player.anim = 1; }
          else { player.vx = 0; player.anim = 0; }

          // (jump will be applied after collision resolves to use correct grounded state)

          // apply velocity
          const oldX = player.x;
          // horizontal
          player.x += player.vx * (dt/1000);
          // vertical physics
          player.vy = player.vy || 0;
          player.vy += GRAV * (dt/1000);
          player.y += player.vy * (dt/1000);

          // footsteps sound when moving
          if(player.anim && Math.abs(player.x - oldX) > 12){ playStep(); }

          // clamp
          if(player.x < 40 * PHYS_SCALE) player.x = 40 * PHYS_SCALE;

          // camera follows player with easing, clamp min at 0 (center the camera on player's collision center)
          const collisionW = player.w * PHYS_SCALE;
          const collisionH = player.h * PHYS_SCALE;
          const playerCenterX = player.x + collisionW * 0.5;
          const targetCam = Math.max(0, playerCenterX - VW*0.35);
          camX += (targetCam - camX) * Math.min(1, dt/200);

          // platform collision (simple ground) — use scaled collision box
          platforms.forEach(p=>{
            if(player.x + collisionW > p.x && player.x < p.x + p.w){
              if(player.y + collisionH > p.y && player.y + collisionH < p.y + p.h + 64){
                // snap to platform (align visual bottom correctly by using collisionH)
                player.y = p.y - collisionH;
                player.vy = 0;
                player.onGround = true;
              }
            }
          });

          // handle jump edge (press while grounded) after collision resolves
          const jumpPressed = jumpKeys.some(k => keys[k]);
          if(jumpPressed && wasOnGround){ player.vy = JUMP_V; player.onGround = false; playStep(); }

          // collectibles (use scaled collision box for detection)
          collectibles.forEach(c=>{
            if(!c.collected){
              if(player.x + collisionW > c.x && player.x < c.x + c.w && player.y + collisionH > c.y && player.y < c.y + c.h){
                c.collected = true; playPickup();
              }
            }
          });

          // scenery proximity triggers
          if(typeof scenery !== 'undefined'){
            scenery.forEach(s=>{
              if(!sceneryTriggered.has(s.x)){
                if(Math.abs(player.x - s.x) < 96){
                  sceneryTriggered.add(s.x);
                  showNarrative(s.text || '', 2600);
                }
              }
            });
          }

          // check win
          const collectedCount = collectibles.filter(c=>c.collected).length;
          if(collectedCount >= COLLECT_TARGET && !window.LEVEL1_DONE){ window.LEVEL1_DONE = true; onComplete(); }
        }

        function draw(){
          // clear
          ctx.fillStyle = '#f4f4f4'; ctx.fillRect(0,0,VW,VH);

          // Draw the composite background (all 5 layers merged) with parallax
          if(compositeBackground){
            const bgW = compositeBackground.width;
            const bgH = compositeBackground.height;
            const parallaxSpeed = 0.3; // Single parallax speed for the whole scene
            const offsetX = -(camX * parallaxSpeed);
            
            // Tile the composite background horizontally
            const startX = Math.floor(offsetX / bgW) * bgW;
            
            // Calculate Y position to anchor bottom of background to groundY
            const bgY = groundY - bgH;
            
            for(let x = startX - bgW; x < VW + bgW; x += bgW){
              ctx.drawImage(compositeBackground, x, bgY, bgW, bgH);
            }
          }else{
            // Fallback: draw old procedural layers if composite not ready
            layers.forEach(layer=>{
              const px = - (camX * layer.speed) % (VW + 200);
              ctx.fillStyle = layer.color;
              for(let x = px - 200; x < VW; x += 400){
                ctx.fillRect(x, layer.y, 360, layer.h);
              }
            });
            // ground fallback
            ctx.fillStyle = '#d0d0d0';
            ctx.fillRect(0, groundY, VW, VH-groundY);
          }

          // draw collectibles (visual enlarged, collision unchanged)
          collectibles.forEach(c=>{
            if(!c.collected){
              const cx = Math.round(c.x - camX);
              const cy = Math.round(c.y + c.h*0.5);
              const r = Math.round(8 * VISUAL_SCALE);
              // soft glow
              ctx.save();
              ctx.shadowBlur = 12 * (VISUAL_SCALE/2);
              ctx.shadowColor = 'rgba(255,255,255,0.9)';
              ctx.fillStyle = '#ffffff';
              ctx.beginPath();
              ctx.arc(cx + c.w/2, cy, r, 0, Math.PI*2);
              ctx.fill();
              ctx.restore();
              // small inner square to keep pixel feel
              ctx.fillStyle = '#f4f4f4';
              ctx.fillRect(Math.round(cx + c.w/2 - r*0.35), Math.round(cy - r*0.35), Math.round(r*0.7), Math.round(r*0.7));
            }
          });

          // draw scenery (prefer sprite images anchored to ground; fallback to richer procedural drawing)
          if(typeof scenery !== 'undefined'){
            scenery.forEach(s=>{
              const sx = Math.round(s.x - camX);
              const img = SPRITE_IMAGES[s.type];
              if(img){
                const iw = img.width; const ih = img.height;
                // allow type-specific scale (buildings should be larger)
                const typeScale = (s.type === 'building') ? 1.2 : 0.9;
                const drawW = Math.round(iw * typeScale);
                const drawH = Math.round(ih * typeScale);
                // anchor using s.y if provided (top Y), otherwise bottom-align to ground
                const drawX = sx - Math.round(drawW/2);
                const drawY = (typeof s.y === 'number') ? Math.round(s.y) : Math.round(groundY - drawH);
                ctx.drawImage(img, drawX, drawY, drawW, drawH);
                return;
              }
              // fallback: richer procedural drawing anchored to s.y if present
              if(s.type === 'tree'){
                const h = 48; const trunkH = 20; const foliageH = h - trunkH;
                const topY = (typeof s.y === 'number') ? s.y : (groundY - h);
                // trunk
                ctx.fillStyle = '#8b6b3a'; ctx.fillRect(sx+6, topY + foliageH, 6, trunkH);
                // foliage
                ctx.fillStyle = '#d9d9d9'; ctx.beginPath(); ctx.ellipse(sx+9, topY + foliageH/2, 30, foliageH/2, 0, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#cfcfcf'; ctx.beginPath(); ctx.ellipse(sx+9, topY + foliageH/2 - 8, 22, foliageH/2 - 6, 0, 0, Math.PI*2); ctx.fill();
              }else if(s.type === 'bench'){
                const w = 44; const h = 12; const topY = (typeof s.y === 'number') ? s.y : (groundY - h - 2);
                ctx.fillStyle = '#cfcfcf'; ctx.fillRect(sx - Math.round(w/2), topY, w, h);
                ctx.fillStyle = '#9f9f9f'; ctx.fillRect(sx - Math.round(w/2), topY + h, 6, 10); ctx.fillRect(sx + Math.round(w/2) - 6, topY + h, 6, 10);
              }else if(s.type === 'building'){
                const w = 240; const h = 128; const topY = (typeof s.y === 'number') ? s.y : (groundY - h);
                ctx.fillStyle = '#e6e6e6'; ctx.fillRect(sx - Math.round(w/2), topY, w, h);
                ctx.fillStyle = '#d0d0d0'; ctx.fillRect(sx - 60, topY + 18, 80, 60);
                ctx.fillStyle = '#c0c0c0'; for(let pl=0;pl<6;pl++) ctx.fillRect(sx - 80, topY + 48 + pl*8, w-40, 6);
              }else if(s.type === 'sign'){
                const h = 40; const topY = (typeof s.y === 'number') ? s.y : (groundY - h);
                ctx.fillStyle = '#bfbfbf'; ctx.fillRect(sx, topY + 6, 6, h - 6);
                ctx.fillStyle = '#ffffff'; ctx.fillRect(sx + 8, topY + 12, 44, 12);
                ctx.fillStyle = '#d0d0d0'; ctx.fillRect(sx + 12, topY + 14, 28, 6);
              }else if(s.type === 'lamp'){
                const h = 56; const topY = (typeof s.y === 'number') ? s.y : (groundY - h);
                ctx.fillStyle = '#8b8b8b'; ctx.fillRect(sx + 8, topY + 6, 6, h - 6);
                ctx.fillStyle = '#fff6d6'; ctx.fillRect(sx - 8, topY - 6, 24, 12);
              }
            });
          }

          // draw player at center-ish
          const px = Math.round(player.x - camX);
          const py = Math.round(player.y);
          // subtle soft shadow under player (no block)
          ctx.save();
          ctx.globalAlpha = 0.12;
          ctx.fillStyle = '#000';
          const shW = 10 * SPRITE_DRAW_SCALE;
          const shH = 3 * SPRITE_DRAW_SCALE;
          ctx.beginPath();
          ctx.ellipse(px + (player.w*SPRITE_DRAW_SCALE)/2, groundY + 6, shW, shH, 0, 0, Math.PI*2);
          ctx.fill();
          ctx.restore();

          // draw player sprite (use loaded spritesheet if available, else fallback to hardcoded)
          if(playerWalkSheet && player.anim){
            // Extract frame from walk spritesheet (assume 10 frames horizontally)
            const totalFrames = 10;
            const frameIndex = Math.floor(animTick) % totalFrames;
            const sw = playerWalkSheet.width / totalFrames;
            const sh = playerWalkSheet.height;
            const dw = sw * (SPRITE_DRAW_SCALE / 2); // scale to match our visual size
            const dh = sh * (SPRITE_DRAW_SCALE / 2);
            ctx.save();
            if(player.dir === -1){
              ctx.scale(-1, 1);
              ctx.drawImage(playerWalkSheet, frameIndex * sw, 0, sw, sh, -px - dw, py, dw, dh);
            }else{
              ctx.drawImage(playerWalkSheet, frameIndex * sw, 0, sw, sh, px, py, dw, dh);
            }
            ctx.restore();
          }else if(playerIdleSheet && !player.anim){
            // Draw idle frame
            const totalFrames = 10;
            const frameIndex = Math.floor(animTick / 2) % totalFrames;
            const sw = playerIdleSheet.width / totalFrames;
            const sh = playerIdleSheet.height;
            const dw = sw * (SPRITE_DRAW_SCALE / 2);
            const dh = sh * (SPRITE_DRAW_SCALE / 2);
            ctx.save();
            if(player.dir === -1){
              ctx.scale(-1, 1);
              ctx.drawImage(playerIdleSheet, frameIndex * sw, 0, sw, sh, -px - dw, py, dw, dh);
            }else{
              ctx.drawImage(playerIdleSheet, frameIndex * sw, 0, sw, sh, px, py, dw, dh);
            }
            ctx.restore();
          }else{
            // fallback: draw hardcoded sprite pixel-by-pixel (monochrome) with 4-frame animation, scaled up
            const frameIndex = Math.floor(animTick) % SPRITES.length;
            const spriteData = SPRITES[frameIndex];
            for(let y=0;y<16;y++){
              const row = spriteData[y];
              for(let x=0;x<16;x++){
                if(row[x] === '1'){
                  ctx.fillStyle = '#0a0a0a';
                  const drawX = (player.dir === 1) ? (px + x*SPRITE_DRAW_SCALE) : (px + (15-x)*SPRITE_DRAW_SCALE);
                  const drawY = py + y*SPRITE_DRAW_SCALE;
                  ctx.fillRect(drawX, drawY, SPRITE_DRAW_SCALE, SPRITE_DRAW_SCALE);
                }
              }
            }
          }

          // draw a small foreground pass from the composite background bottom portion
          // to create depth (part of ground in front of player)
          if(compositeBackground){
            ctx.save();
            ctx.globalAlpha = 0.2;
            const bgW = compositeBackground.width;
            const bgH = compositeBackground.height;
            const parallaxSpeed = 0.3;
            const offsetX = -(camX * parallaxSpeed);
            const startX = Math.floor(offsetX / bgW) * bgW;
            const bgY = groundY - bgH;
            
            // Draw only bottom 30% of composite as foreground overlay
            const clipH = Math.round(bgH * 0.3);
            const clipY = bgH - clipH;
            
            for(let x = startX - bgW; x < VW + bgW; x += bgW){
              ctx.drawImage(compositeBackground, 0, clipY, bgW, clipH, x, bgY + clipY, bgW, clipH);
            }
            ctx.restore();
          }else if(layers.length > 0){
            // fallback to old procedural
            ctx.save();
            ctx.globalAlpha = 0.16;
            const fg = layers[layers.length-1];
            const pxfg = - (camX * fg.speed) % (VW + 200);
            ctx.fillStyle = fg.color;
            for(let x = pxfg - 200; x < VW; x += 400){
              ctx.fillRect(x, fg.y + Math.round(fg.h*0.5), 360, Math.round(fg.h*0.5));
            }
            ctx.restore();
          }

          // HUD: small label & collectibles (subtle)
          const collectedCount = collectibles.filter(c=>c.collected).length;
          ctx.fillStyle = 'rgba(0,0,0,0.28)'; ctx.font = '14px monospace'; ctx.fillText('Collected: ' + collectedCount + ' / ' + COLLECT_TARGET, 12, 26);
          // if reveal in progress draw reveal overlay elements
          drawReveal();
        }

        let last = performance.now();
        let running = false;
        function loop(now){
          const dt = now - last; last = now;
          animTick += (player.anim ? dt/140 : dt/800); // faster when walking
          update(dt);
          draw();
          updateNarrativeAnim(now);
          if(running) requestAnimationFrame(loop);
          else last = performance.now();
        }

        // particle + reveal animation state
        let revealT = 0;
        function onComplete(){
          // animate reveal instead of immediate overlay
          revealT = 1; // start reveal timeline
          try{ if(window.SpliceMain && window.SpliceMain.reportLevelComplete){ window.SpliceMain.reportLevelComplete(1); } }catch(e){}
          const s = JSON.parse(localStorage.getItem('splicing_state_v1')||'{}');
          s.droppedKeys = s.droppedKeys || [];
          if(!s.droppedKeys.includes('1030')) s.droppedKeys.push('1030');
          localStorage.setItem('splicing_state_v1', JSON.stringify(s));
        }

        // simple pixel font (5x7) for large pixel text rendering
        const PIXEL_FONT = {
          '0': [0x7C,0xC6,0xCE,0xD6,0xE6,0xC6,0x7C],
          '1': [0x18,0x38,0x18,0x18,0x18,0x18,0x7E],
          '2': [0x7C,0xC6,0x06,0x1C,0x30,0x66,0xFE],
          '3': [0x7C,0xC6,0x06,0x3C,0x06,0xC6,0x7C]
        };

        function drawPixelText(str, sx, sy, scale, color){
          const gap = 1;
          let x = sx;
          for(const ch of String(str)){
            const pattern = PIXEL_FONT[ch] || PIXEL_FONT['0'];
            for(let row=0; row<pattern.length; row++){
              const bits = pattern[row];
              for(let col=0; col<8; col++){
                if((bits >> (7-col)) & 1){
                  ctx.fillStyle = color;
                  ctx.fillRect(x + col*scale, sy + row*scale, scale, scale);
                }
              }
            }
            x += (8*scale) + gap*scale;
          }
        }

        // draw reveal overlay when revealT>0
        function drawReveal(){
          if(revealT <= 0) return;
          // ease and progress
          revealT += 0.02;
          const p = Math.min(1, revealT);
          // darken background with easing
          ctx.fillStyle = `rgba(10,10,10,${0.6 * p})`;
          ctx.fillRect(0,0,VW,VH);
          // draw large pixel text for key in center
          const text = '1030';
          const scale = 12;
          const totalW = text.length * (8*scale) + (text.length-1)*scale;
          const sx = Math.floor((VW - totalW)/2);
          const sy = Math.floor(VH/2 - (7*scale)/2 - 20);
          drawPixelText(text, sx, sy, scale, '#ffffff');
          // small caption
          ctx.fillStyle = '#fff';
          ctx.font = '20px monospace'; ctx.textAlign = 'center';
          ctx.fillText('Dropped key', VW/2, sy - 10);
          // after fully revealed, show overlay button
          if(p >= 1){ document.getElementById('completeOverlay').style.display = 'flex'; revealT = 0; }
        }

        // ------------------ ambient audio (layered) ------------------
        let ambientNodes = null;
        function startAmbient(){
          ensureAudio(); if(!audioCtx) return;
          if(ambientNodes) return;
          const master = audioCtx.createGain(); master.gain.value = 0.0;
          // gentle global lowpass for warmth
          const lp = audioCtx.createBiquadFilter(); lp.type = 'lowpass'; lp.frequency.value = 1200; lp.Q.value = 0.7;
          master.connect(lp); lp.connect(audioCtx.destination);

          // pad layer 1 (slow sine)
          const pad1 = audioCtx.createOscillator(); pad1.type = 'sine'; pad1.frequency.value = 90;
          const pad1G = audioCtx.createGain(); pad1G.gain.value = 0.0; pad1.connect(pad1G); pad1G.connect(master);

          // pad layer 2 (detuned saw-like via two slightly detuned triangle oscs)
          const pad2a = audioCtx.createOscillator(); pad2a.type = 'triangle'; pad2a.frequency.value = 220;
          const pad2b = audioCtx.createOscillator(); pad2b.type = 'triangle'; pad2b.frequency.value = 222.5;
          const pad2G = audioCtx.createGain(); pad2G.gain.value = 0.0; pad2a.connect(pad2G); pad2b.connect(pad2G); pad2G.connect(master);

          // subtle bell/ding occasional (started/stopped by random timer)
          const bell = audioCtx.createOscillator(); bell.type = 'sine'; bell.frequency.value = 880;
          const bellG = audioCtx.createGain(); bellG.gain.value = 0.0; bell.connect(bellG); bellG.connect(master);

          // ambient slow LFO to modulate pad gains
          const lfo = audioCtx.createOscillator(); lfo.type = 'sine'; lfo.frequency.value = 0.08;
          const lfoG = audioCtx.createGain(); lfoG.gain.value = 0.08; lfo.connect(lfoG);
          // connect lfo to pad gains' gain values via setValueAtTime in interval

          pad1.start(); pad2a.start(); pad2b.start(); bell.start(); lfo.start();

          // ramp in gains slowly
          const t = audioCtx.currentTime;
          pad1G.gain.linearRampToValueAtTime(0.06, t + 3.5);
          pad2G.gain.linearRampToValueAtTime(0.04, t + 4.0);
          master.gain.value = 1.0; // used as control routing through lp

          // occasional bell hits
          ambientNodes = {master, lp, pad1, pad1G, pad2a, pad2b, pad2G, bell, bellG, lfo, lfoG};

          // lfo-based modulation loop (since direct param automation can be limited)
          ambientNodes._modInt = setInterval(()=>{
            const now = audioCtx.currentTime;
            const v = (Math.sin(now * 0.08) + 1) * 0.5; // 0..1
            // use it to subtly modulate pad gains
            pad1G.gain.setTargetAtTime(0.03 + v*0.035, now, 1.2);
            pad2G.gain.setTargetAtTime(0.02 + (1-v)*0.03, now, 1.6);
            // lowpass gentle sweep
            lp.frequency.setTargetAtTime(1000 + v*800, now, 2.2);
            // occasional bell
            if(Math.random() < 0.06){
              const g = audioCtx.createGain(); g.gain.value = 0.0001; bell.connect(g); g.connect(audioCtx.destination);
              const now2 = audioCtx.currentTime;
              g.gain.setValueAtTime(0.0001, now2);
              g.gain.exponentialRampToValueAtTime(0.12, now2 + 0.02);
              g.gain.exponentialRampToValueAtTime(0.0001, now2 + 1.0);
              setTimeout(()=>{ try{ g.disconnect(); }catch(e){} }, 1500);
            }
          }, 420);

          // melodic motif (simple pure-music loop)
          const melody = [220, 246.94, 261.63, 196]; // A3, B3, C4, G3
          let mi = 0;
          ambientNodes._melodyInt = setInterval(()=>{
            const f = melody[mi % melody.length] * (Math.random() < 0.2 ? 0.5 : 1);
            playAmbientNote(f, 0.9, 0.08);
            mi++;
          }, 900);
        }

        function playAmbientNote(freq, dur=0.9, gain=0.06){
          if(!audioCtx) return;
          const o = audioCtx.createOscillator(); o.type = 'sine'; o.frequency.value = freq;
          const g = audioCtx.createGain(); g.gain.value = 0.0001;
          // gentle lowpass per-note
          const f = audioCtx.createBiquadFilter(); f.type = 'lowpass'; f.frequency.value = 2000;
          o.connect(g); g.connect(f); f.connect(audioCtx.destination);
          o.start();
          const now = audioCtx.currentTime;
          g.gain.exponentialRampToValueAtTime(gain, now + 0.02);
          g.gain.exponentialRampToValueAtTime(0.0001, now + dur);
          o.stop(now + dur + 0.05);
        }

        function stopAmbient(){
          if(!ambientNodes) return;
          clearInterval(ambientNodes._modInt);
          const now = audioCtx.currentTime;
          try{
            ambientNodes.pad1G.gain.linearRampToValueAtTime(0.0001, now + 1.2);
            ambientNodes.pad2G.gain.linearRampToValueAtTime(0.0001, now + 1.6);
            ambientNodes.lp.frequency.linearRampToValueAtTime(400, now + 1.6);
          }catch(e){}
          setTimeout(()=>{
            try{ ambientNodes.pad1.stop(); ambientNodes.pad2a.stop(); ambientNodes.pad2b.stop(); ambientNodes.bell.stop(); ambientNodes.lfo.stop(); }catch(e){}
            ambientNodes = null;
          }, 1600);
        }

        // ------------------ scripted events ------------------
        const events = [
          {type:'walk', speed:60, duration:5200},
          {type:'pause', duration:2600, text:'路沿着河，水面安静像一面旧镜子。'},
          {type:'walk', speed:70, duration:6800},
          {type:'pause', duration:3000, text:'树影绕过路肩，叶子在远处低语。'},
          {type:'walk', speed:80, duration:9000},
          {type:'pause', duration:3200, text:'天色偏灰，风里夹着午后的温度。'},
          {type:'walk', speed:90, duration:10000},
          {type:'pause', duration:3600, text:'走得慢些，留一点时间给路上的小事。'}
        ];
        let evIndex = 0; let evTimer = null; let currentEvent = null;

        // scenic decorations and proximity triggers
        const scenery = [
          {x: 760, y: groundY - 72, type:'tree', text: '一棵老槐，树皮有些裂痕。'},
          {x: 1960, y: groundY - 48, type:'bench', text: '长椅上刻着模糊的名字。'},
          {x: 3000, y: groundY - 200, type:'building', text: '远处有一栋低矮的屋子，窗里没有人。'},
          {x: 4600, y: groundY - 64, type:'sign', text: '路牌指向没有名字的村庄。'},
          {x: 6100, y: groundY - 88, type:'lamp', text: '旧路灯还在，夜里会亮。'}
        ];
        const sceneryTriggered = new Set();
        // inline SVG sprites (grayscale) for richer scenery without external assets
        const SPRITE_IMAGES = {};
        (function(){
          const makeURI = s => 'data:image/svg+xml;utf8,' + encodeURIComponent(s);

          // tree svg
          const treeSVG = `
            <svg xmlns='http://www.w3.org/2000/svg' width='180' height='160' viewBox='0 0 180 160'>
              <rect width='100%' height='100%' fill='none'/>
              <g fill='#dcdcdc'>
                <ellipse cx='90' cy='50' rx='70' ry='34' />
                <ellipse cx='60' cy='34' rx='40' ry='26' />
                <ellipse cx='120' cy='34' rx='40' ry='26' />
              </g>
              <g fill='#8b6b3a'>
                <rect x='82' y='70' width='16' height='68' rx='3'/>
              </g>
              <g fill='#bfbfbf' opacity='0.9'>
                <ellipse cx='90' cy='40' rx='20' ry='12'/>
              </g>
            </svg>
          `;

          // bench svg
          const benchSVG = `
            <svg xmlns='http://www.w3.org/2000/svg' width='120' height='64' viewBox='0 0 120 64'>
              <rect width='120' height='64' fill='none'/>
              <rect x='6' y='26' width='108' height='12' fill='#e6e6e6' rx='3'/>
              <rect x='10' y='36' width='8' height='18' fill='#9f9f9f'/>
              <rect x='102' y='36' width='8' height='18' fill='#9f9f9f'/>
              <rect x='14' y='28' width='92' height='6' fill='#cfcfcf' rx='2'/>
            </svg>
          `;

          // building (cabin) svg
          const buildingSVG = `
            <svg xmlns='http://www.w3.org/2000/svg' width='300' height='160' viewBox='0 0 300 160'>
              <rect width='100%' height='100%' fill='none'/>
              <rect x='20' y='48' width='260' height='92' fill='#e6e6e6' rx='4'/>
              <rect x='30' y='58' width='60' height='60' fill='#cfcfcf'/>
              <rect x='90' y='58' width='120' height='12' fill='#dcdcdc'/>
              <rect x='222' y='58' width='28' height='40' fill='#cfcfcf'/>
              <rect x='90' y='82' width='120' height='12' fill='#d0d0d0'/>
              <path d='M20 48 L150 12 L280 48 Z' fill='#d9d9d9'/>
            </svg>
          `;

          // sign svg
          const signSVG = `
            <svg xmlns='http://www.w3.org/2000/svg' width='100' height='80' viewBox='0 0 100 80'>
              <rect width='100' height='80' fill='none'/>
              <rect x='46' y='8' width='8' height='56' fill='#bfbfbf'/>
              <rect x='56' y='18' width='36' height='16' fill='#ffffff' rx='2'/>
              <rect x='62' y='22' width='24' height='8' fill='#d0d0d0' rx='1'/>
            </svg>
          `;

          // lamp svg
          const lampSVG = `
            <svg xmlns='http://www.w3.org/2000/svg' width='60' height='140' viewBox='0 0 60 140'>
              <rect width='60' height='140' fill='none'/>
              <rect x='26' y='30' width='8' height='80' fill='#8b8b8b' rx='2'/>
              <rect x='18' y='18' width='24' height='18' fill='#fff6d6' rx='3'/>
              <rect x='22' y='22' width='16' height='10' fill='#f7e9c8' rx='2'/>
            </svg>
          `;

          const pairs = {tree:treeSVG, bench:benchSVG, building:buildingSVG, sign:signSVG, lamp:lampSVG};
          Object.keys(pairs).forEach(k=>{
            const im = new Image(); im.onload = ()=>{ SPRITE_IMAGES[k] = im; };
            im.onerror = ()=>{ SPRITE_IMAGES[k] = null; };
            im.src = makeURI(pairs[k]);
          });
        })();

        // --- user asset loader + runtime monochrome converter ---
        // Converts any image to black/white/gray 4-level palette
        function convertImageToMonochrome(img){
          const w = img.width, h = img.height;
          const tc = document.createElement('canvas'); tc.width = w; tc.height = h;
          const tctx = tc.getContext('2d'); tctx.drawImage(img,0,0);
          try{
            const id = tctx.getImageData(0,0,w,h);
            const d = id.data;
            // simple 4-level palette mapping (black, dark gray, light gray, white)
            for(let i=0;i<d.length;i+=4){
              const r = d[i], g = d[i+1], b = d[i+2], a = d[i+3];
              if(a < 10){ d[i]=d[i+1]=d[i+2]=0; d[i+3]=0; continue; } // preserve transparency
              const lum = 0.299*r + 0.587*g + 0.114*b; // 0..255
              let v = 0;
              if(lum < 60) v = 0;
              else if(lum < 140) v = 110;
              else if(lum < 200) v = 190;
              else v = 255;
              d[i] = d[i+1] = d[i+2] = v;
            }
            tctx.putImageData(id,0,0);
            return tc;
          }catch(e){
            // CORS or read error — return original canvas
            return tc;
          }
        }

        // Load image and convert to monochrome, return as Image
        function loadAndConvertImage(path, callback){
          const im = new Image(); im.crossOrigin = 'anonymous';
          im.onload = ()=>{
            try{
              const monoCanvas = convertImageToMonochrome(im);
              const monoImg = new Image();
              monoImg.onload = ()=>{ callback(monoImg); };
              monoImg.src = monoCanvas.toDataURL();
            }catch(e){
              callback(im); // fallback to original
            }
          };
          im.onerror = ()=>{ callback(null); };
          im.src = path;
        }

        // Player sprite sheet state
        let playerWalkSheet = null;
        let playerIdleSheet = null;
        let playerRunSheet = null;
        const playerFrameW = 48; // typical frame width (adjust if needed)
        const playerFrameH = 48; // typical frame height

        // Background composite: load 5 layers and merge them into one complete scene
        const bgLayerImages = [];
        let compositeBackground = null;

        // Load player walk spritesheet
        loadAndConvertImage('./assets/player/Walk.png', (img)=>{
          if(img){
            playerWalkSheet = img;
          }
        });

        // Load player idle spritesheet
        loadAndConvertImage('./assets/player/Idle.png', (img)=>{ if(img) playerIdleSheet = img; });

        // Load 5 background layers and composite them into one image
        // These layers stack on top of each other to form the complete background (like pre.png)
        let loadedCount = 0;
        const totalLayers = 5;

        for(let i = 1; i <= totalLayers; i++){
          loadAndConvertImage(`./assets/backgrounds/background/${i}.png`, (img) => {
            if(img){
              bgLayerImages[i-1] = img;
            }
            loadedCount++;
            // Once all layers loaded, composite them
            if(loadedCount === totalLayers){
              compositeBackgroundLayers();
            }
          });
        }

        function compositeBackgroundLayers(){
          // Find the dimensions (use largest width/height from all layers)
          let maxW = 0, maxH = 0;
          bgLayerImages.forEach(img => {
            if(img){
              maxW = Math.max(maxW, img.width);
              maxH = Math.max(maxH, img.height);
            }
          });

          if(maxW === 0 || maxH === 0) return;

          // Create a canvas to composite all layers
          const tempCanvas = document.createElement('canvas');
          tempCanvas.width = maxW;
          tempCanvas.height = maxH;
          const tempCtx = tempCanvas.getContext('2d');

          // Draw layers 1-5 on top of each other
          bgLayerImages.forEach(img => {
            if(img){
              tempCtx.drawImage(img, 0, 0);
            }
          });

          // Convert to image
          compositeBackground = new Image();
          compositeBackground.onload = () => {
            console.log('Composite background ready:', compositeBackground.width, 'x', compositeBackground.height);
          };
          compositeBackground.src = tempCanvas.toDataURL();
        }

        function showNarrative(txt, dur){
          const el = document.getElementById('narrative'); const content = document.getElementById('narrativeText');
          if(!txt){ el.classList.remove('show'); narrativeSpans = []; setTimeout(()=>{ el.style.display = 'none'; }, 420); return; }
          // split into spans so each character can float independently
          content.innerHTML = '';
          const wrap = document.createElement('div'); wrap.className = 'card';
          for(let i=0;i<txt.length;i++){
            const ch = txt[i];
            const sp = document.createElement('span'); sp.textContent = ch;
            sp.style.display = 'inline-block'; sp.style.transform = 'translateY(0px)'; sp.style.willChange = 'transform,opacity'; sp.style.opacity = '0.98';
            sp.style.margin = '0 1px';
            wrap.appendChild(sp);
          }
          content.appendChild(wrap);
          el.style.display = 'block'; setTimeout(()=>{ el.classList.add('show'); }, 20);
          // collect spans for animation
          narrativeSpans = Array.from(wrap.querySelectorAll('span'));
          narrativeStart = performance.now();
          if(dur) setTimeout(()=>{ el.classList.remove('show'); narrativeSpans = []; setTimeout(()=>{ el.style.display = 'none'; }, 420); }, dur);
        }

        function startEventSequence(){ evIndex = 0; runNextEvent(); }
        function fadeScreenTo(op, ms, cb){
          const f = document.getElementById('fadeScreen'); f.style.transition = `opacity ${ms}ms ease`; f.style.opacity = String(op);
          if(cb) setTimeout(cb, ms + 10);
        }

        function runNextEvent(){
          if(evIndex >= events.length){ currentEvent = null; controlMode = 'player'; showNarrative(null); fadeScreenTo(0,400); return; }
          const ev = events[evIndex++]; currentEvent = ev;
          if(ev.type === 'walk'){
            // ensure screen clear, ambient present
            fadeScreenTo(0, 500);
            controlMode = 'auto'; player.vx = ev.speed;
            evTimer = setTimeout(()=>{ runNextEvent(); }, ev.duration);
            showNarrative(null);
          }else if(ev.type === 'pause'){
            // fade down a little, show narrative, then continue
            player.vx = 0;
            fadeScreenTo(0.32, 600, ()=>{
              showNarrative(ev.text || '', ev.duration);
              // keep fade during pause, then remove and continue
              evTimer = setTimeout(()=>{
                fadeScreenTo(0, 600, ()=>{ runNextEvent(); });
              }, ev.duration);
            });
          }
        }

        // narrative animation state
        let narrativeSpans = [];
        let narrativeStart = 0;
        function updateNarrativeAnim(now){
          if(!narrativeSpans || narrativeSpans.length===0) return;
          const t = (now - narrativeStart) / 1000;
          for(let i=0;i<narrativeSpans.length;i++){
            const sp = narrativeSpans[i];
            const phase = i * 0.35;
            const y = Math.sin(t*1.8 + phase) * (6 + Math.sin(t*0.6 + phase)*2);
            sp.style.transform = `translateY(${ -y }px)`;
            // slight opacity shift for depth
            const o = 0.88 + 0.08 * Math.sin(t*1.4 + phase);
            sp.style.opacity = String(o);
          }
        }

        document.getElementById('overlayClose').addEventListener('click', ()=>{
          document.getElementById('completeOverlay').style.display = 'none';
        });

        // start overlay handling
        const startOverlay = document.getElementById('startOverlay');
        const startBtn = document.getElementById('startBtn');
        // Auto-walk + narrative mode (The Longest Road on Earth style)
        let controlMode = 'auto'; // 'auto' | 'player'
        function startGame(){
          startOverlay.style.display = 'none';
          running = true; last = performance.now(); requestAnimationFrame(loop);
          if('ontouchstart' in window) document.getElementById('touchControls').style.display = 'flex';
          // start ambient audio and scripted events
          startAmbient();
          startEventSequence();
        }
        startBtn.addEventListener('click', startGame);
        window.addEventListener('keydown', (e)=>{ if(e.key === 'Enter' && !running) startGame(); });

  // touch control wiring
        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');
        const jumpBtn = document.getElementById('jumpBtn');
        if(leftBtn){
          leftBtn.addEventListener('pointerdown', ()=>{ keys['ArrowLeft'] = true; });
          leftBtn.addEventListener('pointerup', ()=>{ keys['ArrowLeft'] = false; });
          leftBtn.addEventListener('pointercancel', ()=>{ keys['ArrowLeft'] = false; });
        }
        if(rightBtn){
          rightBtn.addEventListener('pointerdown', ()=>{ keys['ArrowRight'] = true; });
          rightBtn.addEventListener('pointerup', ()=>{ keys['ArrowRight'] = false; });
          rightBtn.addEventListener('pointercancel', ()=>{ keys['ArrowRight'] = false; });
        }
        if(jumpBtn){
          jumpBtn.addEventListener('pointerdown', ()=>{ if(player.onGround){ player.vy = JUMP_V; player.onGround = false; playStep(); } });
        }

  // allow click/tap on canvas to step forward briefly (mobile friendly)
  canvas.addEventListener('pointerdown', (e)=>{ if(controlMode === 'player'){ keys['ArrowRight'] = true; setTimeout(()=>{ keys['ArrowRight'] = false; }, 200); } else { /* in auto mode, minor nudge */ player.x += 8; } });

  // don't start until user presses start
      })();
    </script>
  </body>
</html>
